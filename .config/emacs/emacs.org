#+title: Literate Emacs Configuration
#+author: pspiagicw
#+property: header-args:emacs-lisp :tangle ~/.config/emacs/init.el
* Emacs Config
  This is my Emacs Configuration , written as a literate config in Org Mode.
** Advantages
   * Emacs is very customizable using it's own Lisp language , Elisp.
   * Emacs is lightweight
   * Emacs is cross-platform
   * Emacs has a lot of packages and a included package-manager.
   * You can write a literate config!
   * Great Community
** Disadvantages
   * It has quite a high learning curve
   * Needs setting up

* Emacs Installation
  Emacs can be installed using your package manager . ArchLinux provides two packages , ~emacs~ and ~emacs-nox~ . The ~emacs-nox~ package is a terminal application that does not support GUI.
  The ~emacs~ package is the real deal!
  #+begin_src shell
sudo pacman -S emacs
  #+end_src

** Extra Dependencies
   I also use mu4e and it requires two more packages , ~mbsync~ and ~mu~. ~mbsync~ is a mail syncing utility . And ~mu~ is a email indexer that provides Emacs code for controlling it through Emacs.
   
   #+begin_src shell
paru -S mbsync-git and mu
   #+end_src

   For my mbysnc , look at my mbsync config.
   
   
* Ugly Defaults
  Emacs has some ugly defaults , in terms of opening files and storing the internal variables of Emacs.
  These configure Emacs to not store any backup files , which removes the irritating ~#filename#~ files appearing all over your filesystem.

  
  This also configures the location of ~custom.el~ . This file is a internal file created and changed by Emacs.
  By default it is the same as ~init.el~ , which makes your config , really cluttered.

  
** Backup and Autosave
   #+begin_src emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
   #+end_src
   
** Custom.el
   This set's the custom.el file and sources if it exists.
   Emacs keeps all the internal configuration it needs in this file.
   Do not edit this file by hand!
   #+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
   #+end_src
   
** Bells and Whistles
   This disables the visual and audio bell from Emacs.This may cause irritation while using.
   Visual Bell is a flash of white on a invalid function or action. And the audio bell is a audible chime from the PC Speaker of your hardware.
   If you are sensitive to flashes and bright flicker of light , it is advised to disable them.

   #+begin_src emacs-lisp
(setq visible-bell -1)
(setq ring-bell-function 'ignore)
(defalias 'y-or-n-p 'yes-or-no-p)
   #+end_src
  
  
* MELPA and Org-Repo
  Melpa ( Milkpostman's emacs lisp package archive) is a repository of Emacs packages .
  Emacs has GNU ELPA Configuration by default , but it requires registering the package with GNU.
  For this reason there exists multiple repositories , including MELPA and Marmalade.

  In the same spirit org-mode has it's seperate repository!.

  This code edits the ~package-archives~ list  which controls the name and the url of all the repositories.
  If you want to add your own , or change the url , just edit this variable.

  #+begin_src emacs-lisp
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
			 ("elpa" . "https://elpa.gnu.org/packages/")
			 ("org" . "https://orgmode.org/elpa/")))
  #+end_src
  
* Use Package
  Use package is a configuration manager that can install and manage configurations for all packages.
  These packages include the packages installed by default , including Emacs itself!

  #+begin_src emacs-lisp
(require 'use-package)
  #+end_src
  
** Configuring Use Package
   This block configures use-package using use-package's syntax.
   * :config Block to declare any custom configuration after loading the package
   * :init Block to declare any configuration before loading the package
   * :bind Block to bind keybindings related to the package
   * :hooks Block to declare any hook related to the package
   * :magic Block to declare regex expression to load the package
   * :custom Block to have custom variables for the package
   * :ensure Variable to instruct whether to get the package from online repository.
   * :after Variable to store the packages after which to load current package.

   All above handlers are not used , but most are used.

   The ~use-package-always-ensure~ decides if downloading the package is assumed implicit or explicitly defined every time.
   Thus here it assumes that it has to download the package , unless told otherwise.
   #+begin_src emacs-lisp
(use-package use-package
  :config
  (setq use-package-always-ensure t)
)
   #+end_src
   
* UI Configuration
  My UI Configuration is a beautiful collage of packages that make my Emacs experience beautiful along with efficient.

  
** Ugly Modes
   Emacs GUI mode by default incudes , menu , scroll , tool bar.
   This code disables all the above , and let’s the tool tip appear in the mode-line.
   These not only impede the workflow , they are straight up Ugly!
   This also disables the default startup screen of Emacs.
   
   #+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (tooltip-mode -1)
    (setq tooltip-use-echo-area t)
    (setq inhibit-startup-message t)
 )
   #+end_src
   
   
** Fonts
   My font of choice is ~JetBrains Mono~ . It is a font developed by JetBrains for their line of IDE's.
   It is a Open-Source font. It has good differentiation betweek j and J , 0 and O.
   It is extremely readable and availabe as a TTF file , thus portable or downloadable throught the Internet.

   I also use the ~all-the-icons~ package which loads up icons loadable into text.It is needed by ~doom-modeline~.
   #+begin_src emacs-lisp
(setq default-frame-alist '((font . "JetBrains Mono 7")))
   #+end_src

   
   #+begin_src emacs-lisp
(use-package all-the-icons)
   #+end_src
   
 
** Theme
   I use the ~doom-themes~ package. It contains a collection of themes used by ~Doom Emacs~ which is a distribution of Emacs.
   Installing ~doom-themes~ is very easy using use-package

   I use ~doom-dracula~ theme to match up the theme to my system-theme.Inspired by [[https://draculatheme.com][dracula-theme]].

   But I regularly go for different themes for a change!
   This means I probably have a lot of packages installed , all of them are themes
   #+begin_src emacs-lisp
(use-package doom-themes)
(use-package modus-themes)
(use-package dracula-theme)
   #+end_src


   
** Modeline
   I use doom-modeline , which provides a very clean modeline instead of the default emacs modeline.
   It can be customized by setting up variables , altought it requires ~all-the-icons~ for icon-display.
   #+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :init
  (setq doom-modeline-icon t)
  (setq doom-modeline-project-detection 'projectile)
  (setq doom-modeline-buffer-state-icon t)
  (setq doom-modeline-major-mode-color-icon t)
  (setq doom-modeline-buffer-modification-icon t)
  )
   #+end_src
   
** Emacs Dashboard
   Dashboard is a pretty package which provides a startup screen that summarizes the things I was doing inside Emacs , either currently or previously.
   It displays my bookmarks and can be configured to show custom sections , messages , icons etc.
   #+begin_src emacs-lisp
(use-package dashboard
  :config
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (setq dashboard-startup-banner 'logo)
  (setq dashboard-center-content t)
  (setq dashboard-show-shortcuts nil)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-set-navigator t)
  (setq dashboard-projects-switch-function 'counsel-projectile-switch-project-by-name)
  (dashboard-setup-startup-hook)
  )
   #+end_src

   
** Which-Key
   Which Key is a UI helper for all the keybindings inside Emacs.With the ability to theme it and set custom entries it is the best tool for a beginner and advanced Emacs user alike.
   #+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :config
  (setq which-key-idle-delay 0.3)
  (setq which-key-popup-type 'minibuffer)
)
   #+end_src
   
** Display Buffer Alist
   This variable is list that controls how differnt windows are displayed.
   They are selected using regex selection and more information here.

   #+begin_src emacs-lisp
(setq display-buffer-alist
      `(;; no window
	("\\`\\*Async Shell Command\\*\\'"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom))
	("\\*\\(Flymake\\|Package-Lint\\|\\.*compilation.*\\|\\.*terminal.*\\).*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 0))
	("\\*\\(.*compilation.*\\).*"
	 (display-buffer-in-side-window)
	 (window-height . 0.25)
	 (side . bottom)
	 (slot . 0))
	("\\*Messages.*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 1))
	("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 2))
	("\\*\\(Embark\\)?.*Completions.*"
	 (display-buffer-in-side-window)
	 (side . bottom)
	 (slot . 0)
	 (window-parameters . ((no-other-window . t)
			       (mode-line-format . none))))
	("\\*Help.*"            ; See the hooks for `visual-line-mode'
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . -1))
	("\\*Faces\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\*Occur\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("*\\.*mpc.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\.*eww.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("*\\.*terminal.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\.*reddigg.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\*\\(Output\\|Register Preview\\).*"
	 (display-buffer-at-bottom))
	("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
	 (display-buffer-reuse-mode-window display-buffer-at-bottom)
	 (window-height . 0.2))
	("\\*.*\\(e?shell\\|v?term\\).*"
	 (display-buffer-reuse-mode-window display-buffer-at-bottom)
	 (window-height . 0.2))
	;;  )
	)

      )
   #+end_src
  
* Evil Mode
  Evil ( Emacs Vim Emulation) is a package that provides Vim keybindings , without which I cannot live.
  Vim keybindings are the keybindings used with the Vi/Vi Improved editor , devleoped by Bram Moolenar .
  It is considered a sacred competitor to the Vim v/s Emacs editor.
  Every programmer and tech enthusiast has his/her own opinions on this war , including [[][Elon Musk]].
  This has been referenced in numerous shows and movies related to the tech industry.

  Keep in Mind! Linus Torvalds uses a custom version of MuEmacs , which he maintins himself.

  
  
** Evil Package
   This package is the start of the entire barrage of packages. This package provides evil keybindings along with command-mode , visual-mode and many more.
   This covers all the standard Emacs Buffers and is definately better the inbuilt Emacs Vi Emulation!
   #+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration nil)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump t)
  (setq evil-want-C-w-delete t)
  (setq evil-want-C-u-delete t)
  (setq evil-want-minibuffer nil)
  :config
  (evil-set-initial-state 'simple-mpc-mode 'emacs)
  (evil-set-initial-state 'simple-mpc-query-mode 'emacs)
  (evil-set-initial-state 'simple-mpc-current-playlist-mode 'emacs)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  (define-key evil-normal-state-map (kbd "M-l") 'evil-window-right)
  (define-key evil-normal-state-map (kbd "M-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "M-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "M-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "/") 'counsel-grep-or-swiper)
  (define-key evil-normal-state-map (kbd "?") 'counsel-grep-or-swiper)
  (define-key evil-insert-state-map (kbd "M-l") 'evil-window-right)
  (define-key evil-insert-state-map (kbd "M-h") 'evil-window-left)
  (define-key evil-insert-state-map (kbd "M-j") 'evil-window-down)
  (define-key evil-insert-state-map (kbd "M-k") 'evil-window-up)
  ;; (define-key evil-normal-sate-map (kbd ":") 'counsel-M-x)

  ;; this set's up the messages-buffer-mode to normal
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  ;; This set's up the initial mode for evil in Emacs's startup
  (evil-set-initial-state 'dashboard-mode 'normal)
  (evil-mode 1)
)
   #+end_src

   
** Evil Collection
   This is a collection of keybindings that power almost all types of buffers inside Emacs. It has support for external packages and can help in unknown territory while exploring Emacs.

   #+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init)
)
   #+end_src
   
** Evil Surrond
   This package provides the functionality to control characters that occur in pair , including quotes and brackets.
   This is ported from the excellent package ~vim-surround~ provided by Tim Pope.

   #+begin_src emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode t)
)
   #+end_src
   
** Evil Commentary
   This package provides the functionality to control comments . In simple terms this can comment and uncomment lines of code!
   This is also a port of Tim Pope's package vim-commentary.
   #+begin_src emacs-lisp
(use-package evil-commentary
  :config
  (evil-commentary-mode 1)
)
   #+end_src
   
** Evil Matchit
   This package is the port of the package ~matchit~ which is shipped with Vim itself. This package provides keybindings for jumping between matching pairs of code.
   These pairs can include ~if .. else~ and ~try .. catch~ blocks.
   #+begin_src emacs-lisp
(use-package evil-matchit
  :config
  (global-evil-matchit-mode 1)
)
   #+end_src
  
** Evil Numbers
   This package provides the default normal mode keybindings that increment and decrement the next found integer.
   This is a inbuilt ability of Vim.
   #+begin_src emacs-lisp
(use-package evil-numbers
  :config
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  )
   #+end_src
   
** Evil Goggles
   This package provides the functionality of showing a blink while editing large blocks in Evil Mode.
   This is useful while working with large amount of codes. This basically improvides visibility of actions done on code.
   #+begin_src emacs-lisp
(use-package evil-goggles
  :config
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces)
  )
   #+end_src
   
** Evil Escape
   This package provides the ability to keybind a key for escaping any other Emacs mode into Evil Normal Mode.
   I have set it up to use ~jk~ key to exit out of literally anything, that Emacs is doing currently!
   #+begin_src emacs-lisp
(use-package evil-escape
  :init
  (setq-default evil-escape-key-sequence "jk")
  :config
  (evil-escape-mode 1)
)
   #+end_src
   
** Evil Org
   This package provides evil keybindings inside org mode.
   It is set to load after org mode loads.

   #+begin_src emacs-lisp
(use-package evil-org
  :after org
  :hook (org-mode . (lambda () evil-org-mode))
)

   #+end_src
** TODO Evil Undo

* Completion Framework
  Completion Framwork is a ability of an editor to provide functionality in the form the a list.
  This list is filtered using the input provided by the user. This list dynamically updates on each key press.

  This functionality is utilized by many modern text editors , including VS Code , Sublime Text , Atom Text Editor .

  But Emacs and Vim provided that functionality for far longer time.
  By default Emacs does not activate any completion framework although Ido (Interactive Do ) mode is included by default , only to be activated by the user.

  The completion framework that I use is ~ivy~ and ~counsel~ . This framework is famously used by Doom Emacs as opposed to ~Helm~ used by Spacemacs.
  They are both capable completion framework , but ivy is lightweight and easy to start with.

  They are not the only ones on the market.The other ones include , Selectrum , Consult , Icicle , Vertico .
  They may be more written and we can't compare all of them.Although if anytime in the future , there is a job of testing packages for Emacs , I would be interested.

  
** Ivy Setup
   Ivy/Counsel is setup using use-package as usual . It has been populated with Vim Keybindings and works as expected.
   #+begin_src emacs-lisp
(use-package counsel
  :bind (
	 ("C-s" . swiper)
	 ("M-x" . counsel-M-x)
	 ("C-x b" . counsel-switch-buffer)
	 ("C-w" . backward-kill-word)
	 ("C-h" . delete-backward-char)
	 ("C-x C-f" . counsel-find-file)
	 :map minibuffer-local-map
	 ("C-r" . counsel-minibuffer-history)
	 :map ivy-minibuffer-map
	 ("C-l" . ivy-alt-done)
	 ("C-j" . ivy-next-line)
	 ("C-k" . ivy-previous-line)
	 :map ivy-switch-buffer-map
	 ("C-d" . ivy-switch-buffer-kill))
  ("C-j" . ivy-next-line)
  ("C-k" . ivy-previous-line)
  :config
  (counsel-mode 1)
  )
   #+end_src
   
** Ivy Rich
   Ivy Rich is a formatting library complementing Ivy , it adds useful description in the ivy-buffer , as a help.
   It also adds color code for help.

   Althought it is observed to slow down the completion buffer while changing between a lot of buffers , it stays disabled , but remains installed.

   #+begin_src emacs-lisp
(use-package ivy-rich)
   #+end_src
* Programming Languages
  Programming Languages are the reason I spent customizing my editor.
  Here are the programming language based configurations!

  These do not include keybindings according to each programming language , but include language specific settings
  like indentation.
** Indentation and Whitespace
   This sets up the settings for the tab-width.
   This is used as standard for tab-width in all programming languages.

   ~electric-indent-inhibit~ makes sure when I go from one line to another , the indentation is reused , until specified.
   #+begin_src emacs-lisp
(setq tab-width 4)
(setq electric-indent-inhibit t)
   #+end_src
** Auto Parens
   Pairing is handled by ~electric-pair-mode~ and is toggled with a keybinding.
   No initial configuration is neccessary , it is built in to Emacs.
   
** Python
   #+begin_src emacs-lisp
(setq python-shell-interpreter "python")
   #+end_src
** Lisp
** Haskell
   Haskell does not have default syntax highlighting. We need to download ~haskell-mode~ package
   #+begin_src emacs-lisp
(use-package haskell-mode)
   #+end_src
** C
** YAML Mode
   Yaml also does not have default syntax highlighting. It needs ~yaml-mode~
   #+begin_src emacs-lisp
(use-package yaml-mode)
   #+end_src
** Toml Mode
   Syntax highlighting for Toml files.
   #+begin_src emacs-lisp
(use-package toml-mode)
   #+end_src
** Markdown Mode
   Markdown does not have syntax highlighting by default. We need markdown mode.
   #+begin_src emacs-lisp
(use-package markdown-mode)
   #+end_src
** Lua Mode
   Same for Lua
   #+begin_src emacs-lisp
(use-package lua-mode)
   #+end_src
   
** Projectile
   Projectile is a library used to manage code projects. It provides many useful functions and hooks to interface with the project.
   It is used a lot in my keybindings.They provide fast switching between projects
   #+begin_src emacs-lisp
(use-package projectile
  :config
  :custom
  (projectile-completion-system 'ivy)
  (setq projectile-project-search-path '("~/code/python/projects/" "~/code/c/projects/"))
  (setq projectile-switch-project-action #'projectile-dired)
  (projectile-mode 1)
)
   #+end_src

   #+begin_src emacs-lisp
(use-package counsel-projectile
  :config
  (counsel-projectile-mode 1)
)
   #+end_src
   
** Magit
   Magit is a package that is a god-send for a Open Source Developer.
   It is a superb Git client that is impossible to describe in text.
   It is more importantly described in GIFS.
   #+begin_src emacs-lisp
(use-package magit)
   #+end_src

   
  
** LSP
   Language Server Protocol is the new age intellisense system developed along with Microsoft.
   It uses a concept that a server will run in the background and provide autocompletion , jump-to-definition and other goodies,
   while the editor will talk to the server using a JSON system , the editor just needs the client installed,

   This offloads the work from the editor.This also makes the server able to talk to multiple editors.
   It does not matter if the user changes editors , as the server controls the autocompletion and other intellisense configuration.

   #+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :config
  (lsp-enable-which-key-integration t)
)
   #+end_src
   
   
    #+begin_src emacs-lisp
(use-package lsp-ui
  :config
  (lsp-ui-mode 1)
)

    #+end_src

** Company
   Company mode is a package that provides completion according to the sources that can be configured.
   Company can take in inputs from any no of sources and it provides useful keybindings to autocomplete.
   #+begin_src emacs-lisp
(use-package company
  :config
  (setq company-minimum-prefix-length 1
	company-idle-delay 0.0
	company-mode-selection-wrap-around t
	)
  (setq company-backends '((company-lsp)                                                                                                                                                               
			   (company-capf)                                                                                                                                                                                       
			   (company-files)                                                                                                                                                                                      
			   (company-dabbrev-code company-gtags company-etags company-keywords)                                                                                                                                  
			   (company-bbdb)                                                                                                                                                                                       
			   (company-eclim)                                                                                                                                                                                      
			   (company-semantic)                                                                                                                                                                                   
			   (company-clang)                                                                                                                                                                                      
			   (company-xcode)                                                                                                                                                                                      
			   (company-cmake)                                                                                                                                                                                      
			   (company-oddmuse)                                                                                                                                                                                    
			   (company-dabbrev)) 
	)
  )
   #+end_src

   #+begin_src emacs-lisp
(use-package company-quickhelp)
   #+end_src
   
* Org Mode
  Org Mode is one of the selling point of Emacs. It is a mode that transforms text files into pieces of magic.

  
  #+begin_src emacs-lisp
(use-package org
  :config
  (setq org-confirm-elisp-link-function nil)
)
  #+end_src

  Org-Tempo extends the code blocks feature inside org-mode.
  This allows executing code inside code-blocks.
  This also adds keybinding for making code-blocks using ~<s~ syntax.

  Example by typing ~<py~ and pressing TAB , simply expands it into a python code-block,
  and I can easily start typing immediatly.
  
  #+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (C . t)
     (shell . t)
     (haskell . t)))
  (setq org-src-preserve-indentation t)
  (setq org-structure-template-alist
	'(("a" . "export ascii")
	  ("c" . "center")
	  ("C" . "comment")
	  ("e" . "example")
	  ("E" . "export")
	  ("h" . "export html")
	  ("l" . "export latex")
	  ("q" . "quote")
	  ("s" . "src")
	  ("v" . "verse")
	  ("sh" . "src shell")
	  ("py" . "src python")
	  ("el" . "src emacs-lisp")
	  ("hs" . "src haskell")
	  )

	)
  (push '("conf-unix" . conf-unix ) org-src-lang-modes)
  )
  #+end_src
  Org Bullets makes the heading is org-mode a little better to look at.
  It hides all the stars in a heading and shows a special symbol in place of it.
  #+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  )
  #+end_src
* Email
  My Email is controlled using ~mu4e~ and ~mbsync~.

  mu4e is just a email reader , ~mbsync~ downloads the actual mail and ~smtpmail~ package handles sending emails.
  Refer my ~mbsyncrc~ for information on downloading my email.

  MU4E is not a package!. It is a packaged with the ~mu~ package available on most Linux distributions.
  #+begin_src shell
paru -S mbsync-git mu
  #+end_src

  #+begin_src emacs-lisp
(use-package mu4e
  :ensure nil
  :config
  #+end_src

  
  The below code snippet , set's up all of my config for mu4e .
  All of the lines define some settings
  * SMTP Settings: These include smtp settings
    * SMTP Server : All my emails are handled by gmail so I need only one setting for smtp
    * SMTP Service: Gmail by default uses ssl , which has the port 465
    * SMTP Stream Type: This declares the type of encryption used while contacting the server.
      #+begin_src emacs-lisp

  (setq smtpmail-smtp-server "smtp.gmail.com"
	smtpmail-smtp-service 465
	smtpmail-stream-type 'ssl)
      #+end_src
  * Mu4e settings:
    * Mu4e Update Intervals : Interval after which email is reloaded
    * Mu4e Get Mail Commend: Command used to sync my mail
    * Mu4e Mail Dir: Directory where my mail is stored
    * Mu4e Compose Context Policy: Useful if you have multiple mail accounts , it asks which mail account to use while sending mail
    * Mu4e Composed Format Flowed: Allows email to be larger than 80 cols , older email clients did not support email more than 80 cols , but modern one do.
    * Mu4e Context Policy: Whether to ask which email account to use while opening Mu4e.
   
  #+begin_src emacs-lisp
	
  (setq mu4e-change-filenames-while-moving t)
  (setq mu4e-update-interval (* 10 60))
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-maildir "~/.mail")
  (setq mu4e-compose-context-policy 'ask)
  (setq mu4e-compose-format-flowed t)
  (setq mu4e-context-policy 'always-ask)

#+end_src
 * Mu4e Contexts: These are the main bits if you have more than one account.
   It is a list of mu4e context , which store the variables related to the indivisual mail accounts.
   #+begin_src emacs-lisp
  (setq mu4e-contexts
	(list
	 ;; Work Account
   #+end_src
   * Work
     This snippet sets up my work account
     #+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "work"
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/work" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "pspiagicw@gmail.com")
		  (user-full-name . "pspiagicw")
		  (mu4e-drafts-folder . "/work/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/work/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/work/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/work/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/work/Inbox" . ?i)
					      ("/work/[Gmail]/Sent Mail" . ?s)
					      ("/work/[Gmail]/Trash" . ?t)
					      ("/work/[Gmail]/Drafts" . ?d)
					      ("/work/[Gmail]/All Mail" . ?a)
					      ))
		  ))
     #+end_src
   * College Account
     This defines all the variables relate to my college.
     #+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "college"
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/college" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "pratham.sandeep2020@vitbhopal.ac.in")
		  (user-full-name . "Pratham Powar(20BAI10146)")
		  (mu4e-drafts-folder . "/college/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/college/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/college/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/college/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/college/Inbox" . ?i)
					      ("/college/[Gmail]/Sent Mail" . ?s)
					      ("/college/[Gmail]/Trash" . ?t)
					      ("/college/[Gmail]/Drafts" . ?d)
					      ("/college/[Gmail]/All Mail" . ?a)
					      ))
		  ))
     #+end_src
   * Personal
     This is my personal email settings.

#+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "personal"
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "prathampowar2001@gmail.com")
		  (user-full-name . "Pratham Sandeep Powar")
		  (mu4e-drafts-folder . "/personal/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/personal/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/personal/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/personal/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/personal/Inbox" . ?i)
					      ("/personal/[Gmail]/Sent Mail" . ?s)
					      ("/personal/[Gmail]/Trash" . ?t)
					      ("/personal/[Gmail]/Drafts" . ?d)
					      ("/personal/[Gmail]/All Mail" . ?a)
					      ))
		  ))
	 ))
  )
  #+end_src

  
  
* RSS Feeds
  RSS Feeds are the oldy but goldy way for news .
  In simple words , it is a XML file with a list of all the current news and links provided for more information.

  I use elfeed as my RSS Feed reader. You have to provide a list of feeds you want to follow .
  I also customized it's behaviour to include some unique ways of opening urls.
  #+begin_src emacs-lisp
(use-package elfeed
  :config
  (setq elfeed-show-entry-switch #'elfeed-display-buffer)
  (setq elfeed-feeds
	'(
	  ( "https://www.techrepublic.com/rssfeeds/articles/" article tech )
	  ( "https://opensource.com/feed " opensource tech )
	  ( "http://feeds.bbci.co.uk/news/rss.xml?edition=int" news )
	  ( "https://www.cnet.com/rss/news/" news )
	  ( "https://www.space.com/feeds/all" news space )
	  ( "https://towardsdatascience.com/feed" programming )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCVls1GmFKf6WlTraIb_IaJg" youtube linux )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCylGUf9BvQooEFjgdNudoQg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCXuqSBlHAE6Xw-yeJA0Tunw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCld68syR8Wi-GY_n4CaoJGA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCsnGwSIHyoYN0kiINAGUKxg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC6uKrU_WqJ1R2HMTY3LIx5Q" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCL6JmiMXKoXS6bpP1D3bk8g" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCMiJRAwDNSNzuYeN2uWa0pA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBJycsmduvYEL83R_U4JriQ" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBNHHEoiSF8pcLgqLKVugOw" youtube )
	  ( "https://xkcd.com/rss.xml" blog )
	  ( "https://planet.emacsen.org/atom.xml" emacs )
	  ( "https://www.reddit.com/r/emacs/.rss" emacs reddit )
	  ( "https://www.reddit.com/r/linux/.rss" linux reddit )
	  ( "https://www.reddit.com/r/linuxmemes/.rss" linux reddit )
	  ( "https://www.reddit.com/r/vim/.rss" vim reddit )
	  ( "https://www.reddit.com/r/neovim/.rss" vim reddit )
	  ( "https://www.reddit.com/r/archlinux/.rss"  linux  reddit )
	  ( "https://www.reddit.com/r/awesomewm/.rss" linux reddit )
	  ( "https://www.reddit.com/r/google/.rss" news reddit )
	  ( "https://www.reddit.com/r/Python/.rss" programming reddit )
	  ( "https://www.reddit.com/r/suckless/.rss" linux reddit )
	  ( "https://www.reddit.com/r/techhumor/.rss" blog reddit )
	  ( "https://www.reddit.com/r/unixporn/.rss" linux reddit )
	  ( "https://www.reddit.com/r/listentothis/.rss" reddit )
	  ( "https://drewdevault.com/blog/index.xml" blog )
	  ( "https://unixsheikh.com/feed.rss" blog )
	  ( "https://mikestone.me/feed.xml" blog )
	  ( "https://www.phoronix.com/rss.php" )
	  ( "https://fedoramagazine.org/feed/" linux news)
	  ( "https://robertheaton.com/feed" blog )
	  ( "https://reddit.com/r/vimkeyboard/.rss" linux  reddit)
	  ( "https://reddit.com/r/vimporn/.rss" linux reddit)
	  ( "https://reddit.com/r/commandline/.rss" programming reddit)
	  ( "https://distrowatch.com/news/dwd.xml" linux )
	  ( "https://lxer.com/module/newswire/headlines.rss" news )
	  ( "https://betanews.com/feed" news )
	  ( "https://www.computerworld.com/category/linux/index.rss" news )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC88tlMjiS7kf8uhPWyBTn_A"  youtube)
	  ( "http://www.polygon.com/rss/index.xml" blog )
	  ( "http://www.dumbingofage.com/feed/" blog )
	  ( "http://www.smbc-comics.com/rss.php" blog )
	  ( "http://feeds.feedburner.com/codinghorror" tech news)
	  ( "https://news.ycombinator.com/rss" )
	  ( "http://waitbutwhy.com/feed" blog )
	  ( "http://www.gunnerkrigg.com/rss.xml" blog)
	  ( "https://reddit.com/r/technology/.rss"  tech  reddit)
	  ( "https://reddit.com/r/games/.rss"  gaming)
	  ( "http://rss.slashdot.org/Slashdot/slashdot"  tech)
	  ( "https://www.cyberciti.biz/atom/atom.xml" tech news)
	  ( "https://www.gamingonlinux.com/article_rss.php" gaming linux)
	  ( "https://feeds.feedburner.com/Ostechnix" linux tech)
	  ( "https://omgubuntu.co.uk/feed" tech linux)
	  ( "https://www.tecmint.com/feed/" tech news)
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCsBjURrPoezykLs9EqgamOA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC88tlMjiS7kf8uhPWyBTn_A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCCIHOP7e271SIumQgyl6XBQ" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCP2bshADPrVMoNrdJvZEQzw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCP2bshADPrVMoNrdJvZEQzw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC-x4oXG1CJPrhMiARkW9b3A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCRE3NFNtdjR96-H4QG4U1Fg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCxwcmRAmBRzZMNS37dCgmHA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCXPHFM88IlFn68OmLwtPmZA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBa659QWEk1AI5Tg--mrJ2A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCAiiOTio8Yu69c3XnR7nQBQ" youtube )
	  ( "https://pspiagicw.github.io/rss.xml" personal )
	  )
	)
  )
  #+end_src

  
* IRC
  IRC is a old protocol for chatting.
  You have to join a IRC server , thus required registering.
  Good thing is that you can register from the IRC client.
  So no web required!

  #+begin_src emacs-lisp
(use-package erc
  :ensure nil
  :config
  (setq erc-server "irc.libera.chat"
	erc-nick "pspiagicw"
	erc-user-full-name "pspiagicw"
	erc-track-shorten-start 8
	erc-kill-buffer-on-part t
	erc-fill-functional 'erc-fill-static
	erc-fill-static-center 22
	)
  )
  #+end_src
  
* Dired
  Dired is the default ~directory-editor~ inbuilt into Emacs.
  Features include
  * Encryption
  * ZIP , Tar , GZ support
  * Bulk Operations on Files
  * Change modes , owners of Files

  Dired by default is purely text representation
  But we can extend by using ~dired-icons~ which add icons in Dired.
  #+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode)
)
  #+end_src
  
  Dired also has support for toggling visiblity of files according to a regex.
  ~dired-hide-dotfiles~ allows us to toggle hidden files in a single keypress
  
  #+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :hook
  (dired-mode . dired-hide-dotfiles-mode)
)
  #+end_src

* Browsing the Internet
  Browsing the internet using Emacs is possible using EWW.
  EWW allows basic text browsing , bookmarking .
  It does not support javascript ofcourse!
  #+begin_src emacs-lisp
(use-package eww
  :ensure nil
)
  #+end_src

  #+begin_src emacs-lisp
(add-hook 'eww-after-render-hook #'prot-eww--rename-buffer)
(advice-add 'eww-back-url :after #'prot-eww--rename-buffer)
(advice-add 'eww-forward-url :after #'prot-eww--rename-buffer)
  #+end_src

  #+begin_src emacs-lisp
(setq
 shr-use-fonts nil
 shr-use-colors t
 shr-indentation 2
 shr-width 150
 )
  #+end_src

  #+begin_src emacs-lisp

(use-package olivetti)
(add-hook 'eww-mode-hook (lambda () (olivetti-mode)))
  #+end_src

  If you want a proper GUI web browser , look at Emacs Application Framework(EAF).
  
* Opening Files
  Opening files using Dired , opens in the corresponding mode.
  Images open in Image View Mode
  Documents including Office documents open in Doc View Mode.
  But behaviour may or may not be desired.

  Open With package provides a ~openwith-mode~ . This mode has internal list of which filetypes to be opened in which external programs.
  By default it is disabled , as lightwieight files can be opened inside Emacs without any problem.
  But for opening large files , I have assigned a keybinding for toggling ~openwith-mode~.
  
  #+begin_src emacs-lisp
(use-package openwith
  :config
  (setq openwith-associations
	(list
	 (list (openwith-make-extension-regexp
		'("mpg" "mpeg" "mp3" "mp4"
		  "avi" "wmv" "wav" "mov" "flv"
		  "ogm" "ogg" "mkv" "opus" "m4a"))
	       "mpv --force-window"
	       '(file))
	 (list (openwith-make-extension-regexp
		'("xbm" "pbm" "pgm" "ppm" "pnm"
		  "png" "gif" "bmp" "tif" "jpeg" "jpg"))
	       "feh"
	       '(file))
	 (list (openwith-make-extension-regexp
		'("doc" "xls" "ppt" "odt" "ods" "odg" "odp" "docx" "pptx" "xlsx"))
	       "libreoffice"
	       '(file))
	 (list (openwith-make-extension-regexp
		'("pdf" "djvu"))
	       "zathura"
	       '(file))
	 '("\\.lyx" "lyx" (file))
	 '("\\.chm" "kchmviewer" (file))
	 (list (openwith-make-extension-regexp
		'("png" "jpeg" "jpg"))
	       "feh"
	       '(file))
	 ))
  (openwith-mode -1)
  )
  #+end_src
  
  
* Custom Functions
  These functions do my custom actions on some keybindings. These are written by me and changed if needed.
  These may or may not be useful for your setup. Or make your own!
  
** EWW Rename Buffer
   This piece of function changes the name of eww buffer on changing the site by going , forward or backward into the history.
   Originally taken from Protisilous’s Emacs Config.
   
   #+begin_src emacs-lisp
(defun prot-eww--rename-buffer ()
  "Rename EWW buffer using page title or URL.
To be used by `eww-after-render-hook'."
  (let ((name (if (eq "" (plist-get eww-data :title))
		  (plist-get eww-data :url)
		(plist-get eww-data :title))))
    (rename-buffer (format "*%s # eww*" name) t)))
   #+end_src
   
** Elfeed Display Buffer
   This function is a handler for when elfeed wants to display a elfeed entry.
   This function controls how that is shown.
   Right Now it is displayed in any configuration covering 70% of the frame.
   Emacs decides how does it want to dispaly the buffer , but always makes sure , it is not more than 70% of the frame.
   
   
   #+begin_src emacs-lisp
(defun elfeed-display-buffer (buf &optional act)
  (display-buffer buf)
  (set-window-text-height (get-buffer-window) (round (* 0.7 (frame-height)))))
   #+end_src
   
** Kill Dired Buffers
   This function kills all dired buffer in the background!
   It is useful if you think there are a lot of dired buffers and want to kill them
   #+begin_src emacs-lisp
(defun kill-dired-buffers ()
  (interactive)
  (mapc (lambda (buffer) 
	  (when (eq 'dired-mode (buffer-local-value 'major-mode buffer)) 
	    (kill-buffer buffer))) 
	(buffer-list)))
   #+end_src
   
** Custom Switch to Next Theme
   This custom function switches to the next theme.
   Requires initializing a variable known as the theme-index
   #+begin_src emacs-lisp
(setq theme-index 0)
(defun custom-switch-to-next-theme ()
  "Switch to next theme"
  (interactive)
  (let (
	(theme-name (nth theme-index (custom-available-themes)))
	)
    (message "Current Theme: %s" theme-name)
    (setq theme-index (+ theme-index 1))
    (if (> theme-index (length (custom-available-themes)))
	(setq theme-index 0))
    (load-theme theme-name t)

    ))
   #+end_src
   
** Custom Switch to Dashboard
   This function simply finds a buffer named ~*dashbord*~ and switches to it.
   #+begin_src emacs-lisp
(defun custom-switch-to-dashboard ()
  "Switch to dashboard"
  (interactive)
  (switch-to-buffer (get-buffer "*dashboard*"))
  )
   #+end_src
   
** Custom Terminal
   This function controls what happens when I want to open a terminal
   If I am inside a project , I mostly want to open a terminal in the project root.
   Or else I want a terminal then and there, no questions asked!
   #+begin_src emacs-lisp
(defun custom-terminal ()
  "Open a terminal differently depending on whether on project or not"
  (interactive)
  (if (projectile-project-p)
      (projectile-run-eshell)
    (eshell)))
   #+end_src
   
** Custom Grep
   In the same way ~custom-terminal~ works. Custom Grep defines where do I start grepping ?
   In a project projectil-grep takes over and greps over the whole project.
   Or else I simply grep over the current file or directory
   #+begin_src emacs-lisp
(defun custom-grep ()
  "Determines if in project or not and calls required grep function"
  (interactive)
  (if (projectile-project-p)
      (counsel-projectile-grep)
    (counsel-grep)))
   #+end_src
   
** Custom Vsplit
   This vpslit function works as vim splits.
   It splits and takes me to the new split.
   #+begin_src emacs-lisp
(defun custom-vsplit ()
  "Custom vpslit with focus going to split"
  (interactive)
  (evil-window-vsplit)
  (evil-window-right 1))
   #+end_src
   
** Custom Split
   Same as the vsplit , only horizontally
   #+begin_src emacs-lisp
(defun custom-split ()
  "Custom vpslit with focus going to split"
  (interactive)
  (evil-window-split)
  (evil-window-down 1))

   #+end_src
   
** Custom Find file
   If in a project runs ~counsel-projectile-find-file~ or else runs standrd ~counsel-find-file~.
   #+begin_src emacs-lisp
(defun custom-find-file ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (counsel-projectile-find-file)
    (counsel-find-file)))
   #+end_src
   
** Custom Occur
   Occur is a interesting inbuilt package , as it shows us a good summary of what it found.
   Like all my previous function , this runs file based occur if not in a project.
   If yes , it simply runs inside the project.
   #+begin_src emacs-lisp
(defun custom-occur ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (projectile-multi-occur)
    (command-execute 'occur)))
   #+end_src
   
** Custom Switch Buffer
   This function also switches between the project buffers when inside a project.
   And switches between global buffers when outside.
   #+begin_src emacs-lisp
(defun custom-switch-buffer ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (counsel-projectile-switch-to-buffer)
    (counsel-switch-buffer)))
   #+end_src
   
** Custom Dired
   This too works like expected.
   #+begin_src emacs-lisp
(defun custom-dired ()
  "Calls dired depending if in project or not"
  (interactive)
  (if (projectile-project-p)
      (projectile-find-dir)
    (dired (read-directory-name "Dired (directory):"))))

   #+end_src
** Custom Elfeed Back
   This function is built as a alternative the standard elfeed quit.
   This function switches to the ~*elfeed*~ buffer on quiting.
   But becuase of the elfeed customization , this function is rendered useless.
   Kept if needed in the future and as a future reference.
   #+begin_src emacs-lisp
(defun custom-elfeed-back()
  (interactive)
  (elfeed-kill-buffer)
  (switch-to-buffer "*elfeed-search*")
  )
   #+end_src
** Custom MPC Functions
   The functions below are used to control the MPC interface inside Emacs.
   MPC is a inbuilt mode to control the mpd server in Emacs
   #+begin_src emacs-lisp
(defun move-mpc-down ()
  (interactive)
  (evil-next-visual-line)
  (mpc-select)
 )
(defun move-mpc-up ()
  (interactive)
  (evil-previous-visual-line)
  (mpc-select)
 )
   #+end_src
   
* Keybindings
  Keybindings are the most wonderful aspect of the Emacs text editor.
  It originally has very complex keybindings , that only make sense to the experienced Emacs user.

  I use my own keybindings that use SPC key as the leader key. That means I control editor throught keybindings starting with SPC.
  Example

  For opening a file irrespective of my location , I press "SPC ." , which calls a function that does it for me.

  These are a little complex to implement and there are libraries that make it easy to bind keys.

  Some of them are ~bind-keys~ and ~general~ . Both of them are very customizable and can declare complex keybinding schemes.

  I use ~general~ due to the fact that ~Doom Emacs~ used them , I was a previous user of Doom Emacs.

  
** General Installation
   General can be installed using ~use-package~ like any other package. For evil-mode users it includes the ~general-evil-setup~ variable.
   The syntax of general is quite easy to understand but albeit complex to implement it yourself.

** Main Keybindings
   These are the heart of my configuration . Customized by only me , these control the basic movement and usage of the editor.

   These are grouped by their actions i.e keybindings related to windows are invoked by prefix "SPC w".
   #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
  ";" '(counsel-M-x :which-key "Execute a Command")
  ">" '(evil-next-buffer :which-key "Move to Next Buffer")
  "<" '(evil-prev-buffer :which-key "Move to Prev Buffer")
  "/" '(counsel-grep :which-key "Grep in Current Buffer")
  "." '(find-file :which-key "Find File")
)
   #+end_src

   
*** Buffer
    #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "b" '(:ignore t :which-key "Buffer")
 "bn" '(evil-next-buffer :which-key "Switch to next buffer")
 "bp" '(evil-prev-buffer :which-key "Switch to prev buffer")
 "bb" '(counsel-switch-buffer :which-key "Switch to Buffer")
 "br" '(rename-buffer :which-key "Rename buffer")
 "bd" '(evil-delete-buffer :which-key "Delete Buffer")
 "bi" '(ibuffer :which-key "Open Ibuffer")
 "bR" '(read-only-mode :which-key "Toggle Read Only Mode")
 )
    #+end_src

*** Files
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "f" '(:ignore t :which-key "Files")
 "ff" '(counsel-find-file :which-key "Find Files Interactively")
 "fs" '(save-buffer :which-key "Save Current Buffer")
 "fr" '(counsel-recentf :which-key "Find Recent Files")
 "fR" '(rename-file :which-key "Rename File")
 "fC" '(copy-file :which-key "Copy File")
 "fl" '(counsel-locate :which-key "Locate File")
)
    #+end_src

*** Toggles
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "t" '(:ignore t :which-key "Toggle")
 "tt" '(custom-terminal :which-key "Toggle Terminal")
 "tn" '(display-line-numbers-mode :which-key "Toggle Line Numbers")
 "tk" '(which-key-mode :which-key "Toggle Which Key")
 "ta" '(company-mode :which-key "Toggle Autocompletion")
 "tm" '(menu-bar-mode :which-key "Toggle Menu Bar")
 "tf" '(auto-fill-mode :which-key "Toggle Whitespace mode")
 "ti" '(electric-indent-local-mode :which-key "Toggle Auto Indenting")
 "tl" '(hl-line-mode :which-key "Toggle Line Hightlight")
 "tf" '(flymake-mode :which-key "Toggle Flymake")
 "tF" '(text-scale-adjust :which-key "Toggle font sizes")
 "tp" '(electric-pair-local-mode :which-key "Toggle Pairing")
 "tw" '(whitespace-mode :which-key "Toggle Whitespace Mode")
)
    #+end_src

*** Narrow
    #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "n" '(:ignore t :which-key "Narrow")
 "nr" '(narrow-to-region :which-key "Narrow Region")
 "nf" '(narrow-to-defun :which-key "Narrow to Function")
 "np" '(narrow-to-page :which-key "Narrow to Page")
)
    #+end_src

*** Help
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "h" '(:ignore t :which-key "Help")
 "hf" '(describe-function :which-key "Describe Function")
 "hv" '(describe-variable :which-key "Describe Variable")
 "hc" '(describe-key :which-key "Describe Key")
 "hp" '(describe-package :which-key "Describe Package")
 "hi" '(info :which-key "Info Manuals")
 "hm" '(describe-mode :which-key "Describe Mode")
)
    #+end_src
    
*** Projects
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "p" '(:ignore t :which-key "Projects")
 "pp" '(counsel-projectile-switch-project :which-key "Switch Project")
 "pc" '(projectile-compile-project :which-key "Compile Project")
 "pt" '(projectile-test-project :which-key "Test Project")
 "pf" '(counsel-projectile-find-file :which-key "Find File in Project")
 "ps" '(counsel-projectile-grep :which-key "Grep in your Project")
 "pr" '(projectile-run-project :which-key "Run Project")
 "pk" '(projectile-kill-buffers :which-key "Kill all Project buffers")
 "p&" '(projectile-run-async-shell-command-in-root :which-key "Run Command Async in Project")
 "p!" '(projectile-run-command-in-root :which-key "Run Command in Project")
 "pd" '(projectile-find-dir :which-key "Open Dired on Project Root")
 "pg" '(projectile-find-tags :which-key "Find Tags in Project")
 "p%" '(projectile-replace-regexp :which-key "Replace Name in Project")
 "p'" '(projectile-run-term :which-key "Run Term in Root of Project")
)
    #+end_src
    
*** Dired
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "d" '(:ignore t :which-key "Dired")
 "dk" '(kill-dired-buffers :which-key "Kill Dired Buffers")
 "dd" '(custom-dired :which-key "Open Dired")
)
    #+end_src
    
*** Git
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "g" '(:ignore t :which-key "Git")
 "gg" '(magit-status :which-key "Git Status")
 "gc" '(magit-clone :which-key "Git Clone")
)
    #+end_src
    
*** Window
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "w" '(:ignore t :which-key "Window")
 "wv" '(custom-vsplit :which-key "Split Vertically")
 "ws" '(custom-split :which-key "Split Horizonatally")
 "wc" '(evil-window-delete :which-key "Delete Window")
 "w=" '(balance-windows :which-key "Balance Windows")
 "wh" '(evil-window-left :which-key "Move to Left Window")
 "wl" '(evil-window-right :which-key "Move to Right Window")
 "wj" '(evil-window-down :which-key "Move to Below Window")
 "wk" '(evil-window-up :which-key "Move to Top Window")
 "wo" '(delete-other-windows :which-key "Delete other Windows")
 "wu" '(winner-undo :which-key "Undo Window Configuration")
 "wr" '(winner-redo :which-key "Redo Window Configuration")
)
    #+end_src
    
*** Search
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "s" '(:ignore t :which-key "Search")
 "sg" '(grep-find :which-key "Search Using Grep Recursively")
 "ss" '(custom-grep :which-key "Search Using Grep")
 "so" '(custom-occur :which-key "Search Using Occur")
)
    #+end_src
    
*** Apps
    
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "o" '(:ignore t :which-key "Open Applications")
 "oo" '(openwith-mode :which-key "Toggle OpenWith Mode")
 "or" '(reddigg-view-main :which-key "Open Reddit")
 "oa" '(org-agenda :which-key "Org Agenda")
 "om" '(simple-mpc :which-key "Open Simple MPC")
 "ob" '(eww :which-key "Open Browser")
 "oM" '(mu4e :which-key "Open Mu4e")
)
    #+end_src
     
*** Jump
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'override
 :states '(normal visual)
 :prefix "SPC"
 "j" '(:ignore t :which-key "Jump")
 "ji" '(counsel-semantic-or-imenu :which-key "Jump to tag using Imenu")
 )
    #+end_src
    
*** Quit
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "qq" '(delete-frame :which-key "Delete Frame")
 )
    #+end_src
** Modal Keybindings
   These are keybindings that only work while in the particular mode.
   #+begin_src emacs-lisp
(general-define-key
 :keymaps 'override
 :states '(normal visual)
 :prefix "SPC"
 "m" '(:ignore t :which-key "Major Mode")
 )

   #+end_src
   
*** Python Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'python-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "mp" '(run-python :which-key "Open Python REPL")
 "mr" '(python-shell-send-region :which-key "Send region to REPL")
 "mb" '(python-shell-send-buffer :which-key "Send buffer to REPL")
 "mf" '(python-shell-send-defun :which-key "Send function to REPL")
 "ms" '(python-shell-send-statement :which-key "Send statement to REPL")
 "mi" '(:ignore t :which-key "Insert things")
 "mic" '(python-skeleton-class :which-key "Insert class skeleton")
 "mif" '(python-skeleton-for :which-key "Insert for skeleton")
 "mii" '(python-skeleton-import :which-key "Insert for skeleton")
 "mid" '(python-skeleton-def :which-key "Insert def skeleton")
 "mit" '(python-skeleton-try :which-key "Insert try skeleton")
 "miw" '(python-skeleton-while :which-key "Insert while skeleton")
 "mj" '(counsel-imenu :which-key "Jump to definition")
 )
    #+end_src
    
*** Org Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'org-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "mt" '(:ignore t :which-key "org-toggle")
 "me" '(org-export-dispatch :which-key "Org Export")
 "mth" '(org-toggle-heading :which-key "Org Toggle Heading")
 "mti" '(org-toggle-item :which-key "Org Toggle Item")
 "mtt" '(org-todo :which-key "Org toggle todo")
 "mtc" '(org-toggle-checkbox :which-key "Org toggle checkbox")
 "ms" '(org-schedule :which-key "Org Schedul")
 "mc" '(org-ctrl-c-ctrl-c :which-key "Org Ctrl C")
 "ma" '(org-agenda-file-to-front :which-key "Org Agenda Add")
 "mi" '(org-insert-structure-template :which-key "Org Insert Structure")
 "mT" '(org-babel-tangle :which-key "Org Babel Tangle")
 "ml" '(org-insert-link :which-key "Org Insert Link")
 "ml" '(org-insert-link :which-key "Org Insert Link")
 "m'" '(org-edit-special :which-key "Org Edit Special")
 )
    #+end_src

*** Dired Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'dired-mode-map
 :states 'normal
 "h" 'dired-up-directory
 "l" 'dired-find-file
 "." 'dired-hide-dotfiles-mode
 "V" 'dired-mark
 )
    #+end_src
    
*** Elfeed Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'elfeed-show-mode-map
 :states 'normal
 "h" 'custom-elfeed-back
 )
(general-define-key
 :keymaps 'elfeed-search-mode-map
 :states 'normal
 "l" 'elfeed-search-show-entry
 "L" 'scroll-other-window
 )
    #+end_src
    
*** Archive Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'archive-mode-map
 :states 'normal
 "h" 'quit-window
 "l" 'archive-extract
 )
    #+end_src
    
*** Emacs Lisp Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'emacs-lisp-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "me" '(eval-last-sexp :which-key "evaluate last sexp")
 "m:" '(eval-expression :which-key "evaluate lisp func")
 "md" '(eval-defun :which-key "evaluate defun")
 "mb" '(eval-buffer :which-key "evaluate buffer")
 "mr" '(eval-region :which-key "evaluate region")
 "mj" '(counsel-imenu :which-key "Imenu Mode")
 )
    #+end_src

*** MPC Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'mpc-mode-map
 :states 'normal
 "j" 'move-mpc-down
 "k" 'move-mpc-up
 "t" 'mpc-toggle-play
 "r" 'mpc-toggle-repeat
 "s" 'mpc-toggle-shuffle
 "S" 'mpc-toggle-shuffle
 "c" 'mpc-toggle-consume
 "a" 'mpc-playlist-add
 "p" 'mpc-playlist
 ">" 'mpc-next
 "<" 'mpc-prev
 "R" 'mpc-playlist-delete
 "x" 'mpc-play-at-point
 "RET" 'mpc-select
 )
(general-define-key
 :keymaps 'mpc-status-mode-map
 :states 'normal
 "p" 'move-to-mpc-playlist
 )
    #+end_src

*** ERC Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'erc-mode-map
 :states 'normal
 :prefix "SPC"
 "mj" '(erc-join-channel :which-key "ERC Join Channel")
 "mp" '(erc-part-from-channel :which-key "ERC Part Channel")
 "mq" '(erc-quit-server :which-key "ERC Quit Server")
 "mb" '(erc-switch-to-buffer :which-key "ERC Switch Buffer")
 "mt" '(erc-set-topic :which-key "ERC Topic")
 "mn" '(erc-channel-names :which-key "ERC Names")
 )
    #+end_src

    
* Misc Packages or Non-Structured Data
  #+begin_src emacs-lisp
(use-package embark)
  #+end_src

  #+begin_src emacs-lisp
(use-package ox-reveal)
(setq org-reveal-root "file:///home/pspiagicw/.config/emacs/reveal.js")
  #+end_src
