#+title: Literate Emacs Configuration
#+author: pspiagicw
#+latex_class: article
#+latex_class_options: [letterpaper]
#+optioncs: toc:t
#+property: header-args:emacs-lisp :tangle ~/.config/emacs/init.el
* Emacs Config
  This is my Emacs Configuration , written as a literate config in Org Mode.
** Advantages
   * Emacs is very customizable using it's own Lisp language , Elisp.
   * Emacs is lightweight
   * Emacs is cross-platform
   * Emacs has a lot of packages and a included package-manager.
   * You can write a literate config!
   * Great Community
** Disadvantages
   * It has quite a high learning curve
   * Needs setting up

* Emacs Installation
  Emacs can be installed using your package manager . ArchLinux provides two packages , ~emacs~ and ~emacs-nox~ . The ~emacs-nox~ package is a terminal application that does not support GUI.
  The ~emacs~ package is the real deal!
  #+begin_src shell
sudo pacman -S emacs
  #+end_src

** Extra Dependencies
   I also use mu4e and it requires two more packages , ~mbsync~ and ~mu~. ~mbsync~ is a mail syncing utility . And ~mu~ is a email indexer that provides Emacs code for controlling it through Emacs.
   
   #+begin_src shell
paru -S mbsync-git and mu
   #+end_src

   For my mbysnc , look at my mbsync config.
   
   
* Ugly Defaults
  Emacs has some ugly defaults , in terms of opening files and storing the internal variables of Emacs.
  These configure Emacs to not store any backup files , which removes the irritating ~#filename#~ files appearing all over your filesystem.

  
  This also configures the location of ~custom.el~ . This file is a internal file created and changed by Emacs.
  By default it is the same as ~init.el~ , which makes your config , really cluttered.

  
** Backup and Autosave
   #+begin_src emacs-lisp
(setq auto-save-default nil)
(setq make-backup-files t)
(setq backup-directory-alist '(("." . "~/.config/emacs/backup-files")))
(setq backup-by-copying t)
   #+end_src
   
** Custom.el
   This set's the custom.el file and sources if it exists.
   Emacs keeps all the internal configuration it needs in this file.
   Do not edit this file by hand!
   #+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(when (file-exists-p custom-file)
  (load custom-file))
   #+end_src
   
** Bells and Whistles
   This disables the visual and audio bell from Emacs.This may cause irritation while using.
   Visual Bell is a flash of white on a invalid function or action. And the audio bell is a audible chime from the PC Speaker of your hardware.
   If you are sensitive to flashes and bright flicker of light , it is advised to disable them.

   #+begin_src emacs-lisp
(setq visible-bell -1)
(setq ring-bell-function 'ignore)
(defalias 'y-or-n-p 'yes-or-no-p)
   #+end_src
  
** Unique Buffer Names
   #+begin_src emacs-lisp
(use-package uniquify
  :ensure nil
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
  (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
)

   #+end_src
** Mouse Default
   These settings modify how Emacs works when interacted with mouse
   Use File Dialog
   Prevent Emacs from using GUI file dialog when using mouse
     #+begin_src emacs-lisp
       (setq use-file-dialog nil)
       
     #+end_src
   Use Dialog Box
   Prevent Emacs from using GUI 'y-or-n' dialog when using mouse
   #+begin_src emacs-lisp
     (setq use-dialog-box nil)
     
   #+end_src
** Terminal Defaults
   #+begin_src emacs-lisp
     (setq-default shell-file-name "/bin/bash")
     (setq explicit-shell-file-name "/bin/bash")
     
   #+end_src
* MELPA and Org-Repo
  Melpa ( Milkpostman's emacs lisp package archive) is a repository of Emacs packages .
  Emacs has GNU ELPA Configuration by default , but it requires registering the package with GNU.
  For this reason there exists multiple repositories , including MELPA and Marmalade.

  In the same spirit org-mode has it's seperate repository!.

  This code edits the ~package-archives~ list  which controls the name and the url of all the repositories.
  If you want to add your own , or change the url , just edit this variable.

  #+begin_src emacs-lisp
(require 'package)

(setq package-archives '(("melpa" . "https://melpa.org/packages/")
			 ("elpa" . "https://elpa.gnu.org/packages/")
			 ("org" . "https://orgmode.org/elpa/")))
  #+end_src
  
* Use Package
  Use package is a configuration manager that can install and manage configurations for all packages.
  These packages include the packages installed by default , including Emacs itself!

  #+begin_src emacs-lisp
(require 'use-package)
  #+end_src
  
** Configuring Use Package
   This block configures use-package using use-package's syntax.
   * :config Block to declare any custom configuration after loading the package
   * :init Block to declare any configuration before loading the package
   * :bind Block to bind keybindings related to the package
   * :hooks Block to declare any hook related to the package
   * :magic Block to declare regex expression to load the package
   * :custom Block to have custom variables for the package
   * :ensure Variable to instruct whether to get the package from online repository.
   * :after Variable to store the packages after which to load current package.

   All above handlers are not used , but most are used.

   The ~use-package-always-ensure~ decides if downloading the package is assumed implicit or explicitly defined every time.
   Thus here it assumes that it has to download the package , unless told otherwise.
   #+begin_src emacs-lisp
(use-package use-package
  :custom
  (use-package-always-ensure t)
)
   #+end_src
   
* UI Configuration
  My UI Configuration is a beautiful collage of packages that make my Emacs experience beautiful along with efficient.
  
** Ugly Modes
   Emacs GUI mode by default incudes , menu , scroll , tool bar.
   This code disables all the above , and letâ€™s the tool tip appear in the mode-line.
   These not only impede the workflow , they are straight up Ugly!
   This also disables the default startup screen of Emacs.
   
   #+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :custom
  (tooltip-use-echo-area t)
  (inhibit-startup-message t)
  :config
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (tooltip-mode -1)
)
   #+end_src
   
** Fonts
   My font of choice is ~JetBrains Mono~ . It is a font developed by JetBrains for their line of IDE's.
   It is a Open-Source font. It has good differentiation betweek j and J , 0 and O.
   It is extremely readable and availabe as a TTF file , thus portable or downloadable throught the Internet.

   I also use the ~all-the-icons~ package which loads up icons loadable into text.It is needed by ~doom-modeline~.
   
   #+begin_src emacs-lisp
(dolist (face '(default fixed-pitch))
  (set-face-attribute `,face nil :font "JetBrains Mono 8")
)
   #+end_src

   
   #+begin_src emacs-lisp
(use-package all-the-icons)
   #+end_src
   
** Theme
   I use the ~doom-themes~ package. It contains a collection of themes used by ~Doom Emacs~ which is a distribution of Emacs.
   Installing ~doom-themes~ is very easy using use-package

   I use ~doom-dracula~ theme to match up the theme to my system-theme.Inspired by [[https://draculatheme.com][dracula-theme]].

   But I regularly go for different themes for a change!
   This means I probably have a lot of packages installed , all of them are themes
   #+begin_src emacs-lisp
(use-package doom-themes)
(use-package dracula-theme)
(load-theme 'doom-nord t)

   #+end_src


** Modeline
   I use doom-modeline , which provides a very clean modeline instead of the default emacs modeline.
   It can be customized by setting up variables , altought it requires ~all-the-icons~ for icon-display.
   #+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :custom
  (doom-modeline-icon t)
  (doom-modeline-project-detection 'projectile)
  (doom-modeline-buffer-state-icon t)
  (doom-modeline-major-mode-color-icon t)
  (doom-modeline-buffer-modification-icon t)
)
   #+end_src
   
** Emacs Dashboard
   Dashboard is a pretty package which provides a startup screen that summarizes the things I was doing inside Emacs , either currently or previously.
   It displays my bookmarks and can be configured to show custom sections , messages , icons etc.
   #+begin_src emacs-lisp
(use-package dashboard
  :config
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (setq dashboard-startup-banner "~/.config/emacs/doom.txt")
  (setq dashboard-center-content t)
  (setq dashboard-show-shortcuts nil)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-set-navigator t)
  (setq dashboard-projects-switch-function 'project-switch-project)
  (dashboard-setup-startup-hook)
  )
   #+end_src

   
** Which-Key
   Which Key is a UI helper for all the keybindings inside Emacs.With the ability to theme it and set custom entries it is the best tool for a beginner and advanced Emacs user alike.
   #+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :custom
  (which-key-idle-delay 0.3)
  (which-key-popup-type 'minibuffer)
)
   #+end_src
   
** Display Buffer Alist
   This variable is list that controls how differnt windows are displayed.
   They are selected using regex selection and more information here.

   #+begin_src emacs-lisp
(setq display-buffer-alist
      `(;; no window
	("\\`\\*Async Shell Command\\*\\'"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom))
	("\\*\\(Flymake\\|Package-Lint\\|\\.*compilation.*\\|\\.*terminal.*\\).*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 0))
	("\\*\\(.*compilation.*\\).*"
	 (display-buffer-in-side-window)
	 (window-height . 0.25)
	 (side . bottom)
	 (slot . 0))
	("\\*Messages.*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 1))
	("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
	 (display-buffer-in-side-window)
	 (window-height . 0.16)
	 (side . bottom)
	 (slot . 2))
	("\\*\\(Embark\\)?.*Completions.*"
	 (display-buffer-in-side-window)
	 (side . bottom)
	 (slot . 0)
	 (window-parameters . ((no-other-window . t)
			       (mode-line-format . none))))
	("\\*Help.*"            ; See the hooks for `visual-line-mode'
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . -1))
	("\\*Faces\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\*Occur\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("*\\.*mpc.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	;; ("\\.*eww.*\\*"
	;;  (display-buffer-in-side-window)
	;;  (window-width . 0.25)
	;;  (side . right)
	;;  (slot . 0))
	("*\\.*terminal.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("*\\.*term-.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\.*reddigg.*\\*"
	 (display-buffer-in-side-window)
	 (window-width . 0.25)
	 (side . right)
	 (slot . 0))
	("\\*\\(Output\\|Register Preview\\).*"
	 (display-buffer-at-bottom))
	("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
	 (display-buffer-reuse-mode-window display-buffer-at-bottom)
	 (window-height . 0.2))
	("\\*.*\\(e?shell\\|v?term\\).*"
	 (display-buffer-reuse-mode-window display-buffer-at-bottom)
	 (window-height . 0.2))
	  )
	)

   #+end_src
  
* Evil Mode
  Evil ( Emacs Vim Emulation) is a package that provides Vim keybindings , without which I cannot live.
  Vim keybindings are the keybindings used with the Vi/Vi Improved editor , devleoped by Bram Moolenar .
  It is considered a sacred competitor to the Vim v/s Emacs editor.
  Every programmer and tech enthusiast has his/her own opinions on this war , including [[][Elon Musk]].
  This has been referenced in numerous shows and movies related to the tech industry.

  Keep in Mind! Linus Torvalds uses a custom version of MuEmacs , which he maintins himself.

  
  
** Evil Package
   This package is the start of the entire barrage of packages. This package provides evil keybindings along with command-mode , visual-mode and many more.
   This covers all the standard Emacs Buffers and is definately better the inbuilt Emacs Vi Emulation!
   #+begin_src emacs-lisp
(use-package evil
  :custom
  (evil-want-integration nil)
  (evil-want-keybinding nil)
  (evil-want-C-u-scroll t)
  (evil-want-C-i-jump t)
  (evil-want-C-w-delete t)
  (evil-want-C-u-delete t)
  (evil-want-minibuffer nil)
  (evil-undo-system 'undo-tree)
  :config
  (evil-set-initial-state 'simple-mpc-mode 'emacs)
  (evil-set-initial-state 'simple-mpc-query-mode 'emacs)
  (evil-set-initial-state 'simple-mpc-current-playlist-mode 'emacs)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
  (define-key evil-insert-state-map (kbd "C-w") 'evil-delete-backward-word)

  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  (define-key evil-normal-state-map (kbd "/") 'evil-search-forward)
  (define-key evil-normal-state-map (kbd "?") 'evil-search-backward)

  ;; this set's up the messages-buffer-mode to normal
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  ;; This set's up the initial mode for evil in Emacs's startup
  (evil-set-initial-state 'dashboard-mode 'normal)
  (evil-mode 1)
)
   #+end_src

   
** Evil Collection
   This is a collection of keybindings that power almost all types of buffers inside Emacs. It has support for external packages and can help in unknown territory while exploring Emacs.

   #+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init)
)
   #+end_src
   
** Evil Surrond
   This package provides the functionality to control characters that occur in pair , including quotes and brackets.
   This is ported from the excellent package ~vim-surround~ provided by Tim Pope.

   #+begin_src emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode t)
)
   #+end_src
   
** Evil Commentary
   This package provides the functionality to control comments . In simple terms this can comment and uncomment lines of code!
   This is also a port of Tim Pope's package vim-commentary.
   #+begin_src emacs-lisp
(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode 1)
)
   #+end_src
   
** Evil Matchit
   This package is the port of the package ~matchit~ which is shipped with Vim itself. This package provides keybindings for jumping between matching pairs of code.
   These pairs can include ~if .. else~ and ~try .. catch~ blocks.
   #+begin_src emacs-lisp
(use-package evil-matchit
  :after evil
  :config
  (global-evil-matchit-mode 1)
)
   #+end_src
  
** Evil Numbers
   This package provides the default normal mode keybindings that increment and decrement the next found integer.
   This is a inbuilt ability of Vim.
   #+begin_src emacs-lisp
(use-package evil-numbers
  :after evil
  :config
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  )
   #+end_src
   
** Evil Goggles
   This package provides the functionality of showing a blink while editing large blocks in Evil Mode.
   This is useful while working with large amount of codes. This basically improvides visibility of actions done on code.
   #+begin_src emacs-lisp
(use-package evil-goggles
  :after evil
  :config
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces)
  )
   #+end_src
   
** Evil Escape
   This package provides the ability to keybind a key for escaping any other Emacs mode into Evil Normal Mode.
   I have set it up to use ~jk~ key to exit out of literally anything, that Emacs is doing currently!
   #+begin_src emacs-lisp
(use-package evil-escape
  :init
  (setq-default evil-escape-key-sequence "jk")
  :config
  (evil-escape-mode 1)
)
   #+end_src
   
** Evil Org
   This package provides evil keybindings inside org mode.
   It is set to load after org mode loads.

   #+begin_src emacs-lisp
(use-package evil-org
  :after org
  :hook (org-mode . evil-org-mode)
)

   #+end_src
** DONE Evil Undo

   This is the package needed for redo and undo functionality in Evil Mode.
   #+begin_src emacs-lisp
(use-package undo-tree
  :config
  (global-undo-tree-mode 1)
 )
   #+end_src
* Completion Framework
  Completion Framwork is a ability of an editor to provide functionality in the form the a list.
  This list is filtered using the input provided by the user. This list dynamically updates on each key press.

  This functionality is utilized by many modern text editors , including VS Code , Sublime Text , Atom Text Editor .

  But Emacs and Vim provided that functionality for far longer time.
  By default Emacs does not activate any completion framework although Ido (Interactive Do ) mode is included by default , only to be activated by the user.

  The completion framework that I use is ~ivy~ and ~counsel~ . This framework is famously used by Doom Emacs as opposed to ~Helm~ used by Spacemacs.
  They are both capable completion framework , but ivy is lightweight and easy to start with.

  They are not the only ones on the market.The other ones include , Selectrum , Consult , Icicle , Vertico .
  They may be more written and we can't compare all of them.Although if anytime in the future , there is a job of testing packages for Emacs , I would be interested.

  
** Ivy-Mode [Now: Using Vertico]
   Ivy/Counsel is setup using use-package as usual . It has been populated with Vim Keybindings and works as expected.
   #+begin_src emacs-lisp
     ;; (use-package ivy
     ;;   :bind (
     ;; 	 ("C-w" . backward-kill-word)
     ;; 	 ("C-h" . delete-backward-char)
     ;; 	 :map ivy-minibuffer-map
     ;; 	 ("C-l" . ivy-alt-done)
     ;; 	 ("C-j" . ivy-next-line)
     ;; 	 ("C-k" . ivy-previous-line)
     ;; 	 ("C-<return>" . ivy-alt-done)
     ;; 	 :map ivy-switch-buffer-map
     ;; 	 ("C-d" . ivy-switch-buffer-kill))

     ;;   ("C-j" . ivy-next-line)
     ;;   ("C-k" . ivy-previous-line)
     ;;   :config
     ;;   (setq ivy-re-builders-alist
     ;; 	'((t      . ivy--regex-plus)))
     ;;   )

(use-package vertico
  :bind (:map vertico-map
	      ("C-j" . vertico-next)
	      ("C-k" . vertico-previous)
	      ("C-w" . backward-kill-word)
	      ("C-h" . delete-backward-char)
	      ))
	 #+end_src
   
** Ivy Rich [Now: Marginalia]
   Ivy Rich is a formatting library complementing Ivy , it adds useful description in the ivy-buffer , as a help.
   It also adds color code for help.

   Althought it is observed to slow down the completion buffer while changing between a lot of buffers , it stays disabled , but remains installed.

   Edit: Now I am using Marginalia for above features.

   #+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode 1)
)

   #+end_src
** Completion Commands
   All the completion commands independent of any completion framework is provided by ~Consult~.
   #+begin_src emacs-lisp
(use-package consult)
   #+end_src
** Completion Styles
   This defines the style of completion , this governs how each completion candidate is considered while listing in the completion buffer.
   #+begin_src emacs-lisp
(use-package orderless
  :config
  (setq completion-styles '(orderless))
)
   #+end_src
   
* Programming Languages
  Programming Languages are the reason I spent customizing my editor.
  Here are the programming language based configurations!
  
  These do not include keybindings according to each programming language , but include language specific settings
  like indentation.
** Indentation and Whitespace
   This sets up the settings for the tab-width.
   This is used as standard for tab-width in all programming languages.

   ~electric-indent-inhibit~ makes sure when I go from one line to another , the indentation is reused , until specified.
   #+begin_src emacs-lisp
(setq tab-width 4)
(setq electric-indent-inhibit t)
   #+end_src
** Auto Parens
   Pairing is handled by ~electric-pair-mode~ and is toggled with a keybinding.
   No initial configuration is neccessary , it is built in to Emacs.
   
** Python
   #+begin_src emacs-lisp
(setq python-shell-interpreter "python")
   #+end_src
** Lisp
** Haskell
   Haskell does not have default syntax highlighting. We need to download ~haskell-mode~ package
   #+begin_src emacs-lisp
(use-package haskell-mode)
   #+end_src
** C
** YAML Mode
   Yaml also does not have default syntax highlighting. It needs ~yaml-mode~
   #+begin_src emacs-lisp
(use-package yaml-mode)
   #+end_src
** Toml Mode
   Syntax highlighting for Toml files.
   #+begin_src emacs-lisp
(use-package toml-mode)
   #+end_src
** Markdown Mode
   Markdown does not have syntax highlighting by default. We need markdown mode.
   #+begin_src emacs-lisp
(use-package markdown-mode)
   #+end_src
** Lua Mode
   Same for Lua
   #+begin_src emacs-lisp
(use-package lua-mode)
   #+end_src
** Golang Mode
   I use Golang as a low-level language
   #+begin_src emacs-lisp
(use-package go-mode)
   #+end_src
   For integrating with org-mode
   #+begin_src emacs-lisp
(use-package ob-go)
   #+end_src
** Projectile
   Projectile is a library used to manage code projects. It provides many useful functions and hooks to interface with the project.
   It is used a lot in my keybindings.They provide fast switching between projects
   #+begin_src emacs-lisp
;; (use-package projectile
;;   :config
;;   (projectile-mode 1)
;;   :custom
;;   (projectile-completion-system 'ivy)
;;   (projectile-project-search-path '("~/code/python/projects/" "~/code/c/projects/"))
;;   (projectile-switch-project-action #'projectile-dired)
;; )
   #+end_src

   #+begin_src emacs-lisp
;; (use-package counsel-projectile
;;   :after projectile
;;   :config
;;   (counsel-projectile-mode 1)
;; )
   #+end_src
   
** Magit
   Magit is a package that is a god-send for a Open Source Developer.
   It is a superb Git client that is impossible to describe in text.
   It is more importantly described in GIFS.
   #+begin_src emacs-lisp
(use-package magit)
   #+end_src

   
** Jupyter Notebooks
   Jupyter notebook allow running kernels of any language.I use it for Machine Learning and Deep Learning stuff in Python
   #+begin_src emacs-lisp
(use-package jupyter)
   #+end_src
  
** LSP
   Language Server Protocol is the new age intellisense system developed along with Microsoft.
   It uses a concept that a server will run in the background and provide autocompletion , jump-to-definition and other goodies,
   while the editor will talk to the server using a JSON system , the editor just needs the client installed,

   This offloads the work from the editor.This also makes the server able to talk to multiple editors.
   It does not matter if the user changes editors , as the server controls the autocompletion and other intellisense configuration.

   #+begin_src emacs-lisp
(use-package lsp-mode
  :commands (lsp lsp-deferred)
  :config
  (lsp-enable-which-key-integration t)
)
(use-package lsp-jedi
)
   #+end_src
   
   
    #+begin_src emacs-lisp
;; (use-package lsp-ui)

    #+end_src

** Company
   Company mode is a package that provides completion according to the sources that can be configured.
   Company can take in inputs from any no of sources and it provides useful keybindings to autocomplete.
   #+begin_src emacs-lisp
(use-package company
  :commands (company-mode)
  :config
  (company-tng-configure-default)
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0)
  (company-mode-selection-wrap-around t)
  (company-backends '((company-lsp)                                                                                                                                                               
		      (company-files)                                                                                                                                                                                      
		      (company-capf)                                                                                                                                                                                      
		      (company-dabbrev)                                                                                                                                                                                      
		      (company-dabbrev-code company-gtags company-etags company-keywords)                                                                                                                                  
		      (company-semantic)                                                                                                                                                                                   
		      (company-clang)                                                                                                                                                                                      
		      (company-cmake)                                                                                                                                                                                      
		      (company-dabbrev)) 
		    )
  )
   #+end_src

   #+begin_src emacs-lisp
(use-package company-quickhelp
  :after company
  )
   #+end_src
   
* Org Mode
  Org Mode is one of the selling point of Emacs. It is a mode that transforms text files into pieces of magic.

  
  #+begin_src emacs-lisp
(use-package org
  :custom
  (org-confirm-elisp-link-function nil)
)
  #+end_src

  Org-Tempo extends the code blocks feature inside org-mode.
  This allows executing code inside code-blocks.
  This also adds keybinding for making code-blocks using ~<s~ syntax.

  Example by typing ~<py~ and pressing TAB , simply expands it into a python code-block,
  and I can easily start typing immediatly.
  
  #+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil
  :config
  (push '("conf-unix" . conf-unix ) org-src-lang-modes)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (C . t)
     (shell . t)
     (haskell . t)
     (sql . t)
     (jupyter . t)
     (go . t)
))
  :custom
  (org-src-preserve-indentation t)
  (org-structure-template-alist
	'(("a" . "export ascii")
	  ("c" . "center")
	  ("C" . "comment")
	  ("e" . "example")
	  ("E" . "export")
	  ("h" . "export html")
	  ("l" . "export latex")
	  ("q" . "quote")
	  ("s" . "src")
	  ("v" . "verse")
	  ("sh" . "src shell")
	  ("py" . "src python")
	  ("el" . "src emacs-lisp")
	  ("hs" . "src haskell")
	  ("sq" . "src sql")
	  ("ml" . "src jupyter-python :session default :async yes")
	  )

	)


  )
  #+end_src
  Org Bullets makes the heading is org-mode a little better to look at.
  It hides all the stars in a heading and shows a special symbol in place of it.
  
  Org Roam is a knowledge preservation system , written in Org Mode. It uses SQLite database to keep backlinks and thus allows for interconnected non-hierarchial data.
  #+begin_src emacs-lisp
(use-package org-roam
  :init
  (setq org-roam-v2-ack t)
  :config
  (setq org-roam-directory "~/documents/org/org-roam")
  (setq org-roam-completion-everywhere t)
  (org-roam-setup)
)
(general-define-key
 :prefix "SPC"
 :keymaps 'override
 :states 'normal
 "r" '(:ignore t :which-key "Org Roam")
 "ri" '(org-roam-node-insert :which-key "Insert Org Roam Node")
 "rf" '(org-roam-node-find :which-key "Find Org Roam Node")
 "rl" '(org-roam-buffer-toggle)
 )
  #+end_src
  Org Capture allows us to capture stuff for futher inspection or rather a TODO with a schedule , etc.
  Arrange meetings and so much more.

  #+begin_src emacs-lisp
(use-package org-capture
  :ensure nil
  :config
  (setq org-directory "~/documents/org")
  (setq org-agenda-files '("~/documents/org/tasks"))
  (setq org-capture-templates
	'(
	  ("c" "College Task" entry
	   (file+headline "tasks/college.org" "College Tasks")
	   "* TODO Task: %?")
	  ("w" "Work Task" entry
	   (file+headline "tasks/work.org" "Work Tasks")
	   "* TODO Task: %?")
	  ("n" "Next Task" entry
	   (file+headline "tasks/next.org" "Next Tasks")
	   "* NEXT Task: %? \nDEADLINE: %t")
	  ("r" "Read Task" entry
	   (file+headline "tasks/read.org" "Things to Read")
	   "* RESEARCH %?")
	  ("m" "Watch Task" entry
	   (file+headline "tasks/watch.org" "Things to Watch Later")
	   "* WATCH %?")
	  ("t" "General Tasks" entry
	   (file+headline "tasks/general.org" "General Tasks")
	   "* TODO Task: %?")
	  )
	)
  (setq org-todo-keywords
	'((sequence "TODO" "RESEARCH" "NEXT" "WATCH" "|" "DONE" "CANCELLED")))
  )
  #+end_src
  Ox Hugo allows exporting ORG Mode into HUGO compatible markdownd
  #+begin_src emacs-lisp

(use-package ox-hugo
  :after ox
  :config
  (setq org-hugo-base-dir "~/documents/personalblog")
)
  #+end_src
* Email
  My Email is controlled using ~mu4e~ and ~mbsync~.

  mu4e is just a email reader , ~mbsync~ downloads the actual mail and ~smtpmail~ package handles sending emails.
  Refer my ~mbsyncrc~ for information on downloading my email.

  MU4E is not a package!. It is a packaged with the ~mu~ package available on most Linux distributions.
  #+begin_src shell
paru -S mbsync-git mu
  #+end_src

  #+begin_src emacs-lisp
(use-package mu4e
  :ensure nil
  :config
  #+end_src

  
  The below code snippet , set's up all of my config for mu4e .
  All of the lines define some settings
  * SMTP Settings: These include smtp settings
    * SMTP Server : All my emails are handled by gmail so I need only one setting for smtp
    * SMTP Service: Gmail by default uses ssl , which has the port 465
    * SMTP Stream Type: This declares the type of encryption used while contacting the server.
    Edit: For Now Mail sending handled by msmtp!
      #+begin_src emacs-lisp

  ;; (setq smtpmail-smtp-server "smtp.gmail.com"
  ;; 	smtpmail-smtp-service 465
  ;; 	send-mail-function 'smtpmail-send-it
  ;; 	smtpmail-stream-type 'ssl)
(setq send-mail-function 'sendmail-send-it
      message-send-mail-function 'message-send-mail-with-sendmail
      sendmail-program "/usr/bin/msmtp"
      message-sendmail-extra-arguments '("--read-envelope-from")
      message-sendmail-f-is-evil 't
       )
      #+end_src
  * Mu4e settings:
    * Mu4e Update Intervals : Interval after which email is reloaded
    * Mu4e Get Mail Commend: Command used to sync my mail
    * Mu4e Mail Dir: Directory where my mail is stored
    * Mu4e Compose Context Policy: Useful if you have multiple mail accounts , it asks which mail account to use while sending mail
    * Mu4e Composed Format Flowed: Allows email to be larger than 80 cols , older email clients did not support email more than 80 cols , but modern one do.
    * Mu4e Context Policy: Whether to ask which email account to use while opening Mu4e.
   
  #+begin_src emacs-lisp
	
  (setq mu4e-change-filenames-while-moving t)
  (setq mu4e-update-interval (* 10 60))
  (setq mu4e-get-mail-command "mbsync -a")
  (setq mu4e-maildir "~/.mail")
  (setq mu4e-compose-context-policy 'ask)
  (setq mu4e-compose-format-flowed t)
  (setq mu4e-context-policy 'always-ask)


#+end_src
 * Mu4e Contexts: These are the main bits if you have more than one account.
   It is a list of mu4e context , which store the variables related to the indivisual mail accounts.
   #+begin_src emacs-lisp
  (setq mu4e-contexts
	(list
	 ;; Work Account
   #+end_src
   * Work
     This snippet sets up my work account
     #+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "work"
	  :leave-func (lambda () (mu4e-clear-caches))
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/work" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "pspiagicw@gmail.com")
		  (user-full-name . "pspiagicw")
		  (mu4e-drafts-folder . "/work/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/work/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/work/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/work/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/work/Inbox" . ?i)
					      ("/work/[Gmail]/Sent Mail" . ?s)
					      ("/work/[Gmail]/Trash" . ?t)
					      ("/work/[Gmail]/Drafts" . ?d)
					      ("/work/[Gmail]/All Mail" . ?a)
					      ))
		  ))
     #+end_src
   * College Account
     This defines all the variables relate to my college.
     #+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "college"
	  :leave-func (lambda () (mu4e-clear-caches))
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/college" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "pratham.sandeep2020@vitbhopal.ac.in")
		  (user-full-name . "Pratham Powar(20BAI10146)")
		  (mu4e-drafts-folder . "/college/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/college/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/college/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/college/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/college/Inbox" . ?i)
					      ("/college/[Gmail]/Sent Mail" . ?s)
					      ("/college/[Gmail]/Trash" . ?t)
					      ("/college/[Gmail]/Drafts" . ?d)
					      ("/college/[Gmail]/All Mail" . ?a)
					      ))
		  ))
     #+end_src
   * Personal
     This is my personal email settings.

#+begin_src emacs-lisp
	 (make-mu4e-context
	  :name "personal"
	  :leave-func (lambda () (mu4e-clear-caches))
	  :match-func
	  (lambda (msg)
	    (when msg
	      (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
	  :vars '(
		  (user-mail-address . "prathampowar2001@gmail.com")
		  (user-full-name . "Pratham Sandeep Powar")
		  (mu4e-drafts-folder . "/personal/[Gmail]/Drafts")
		  (mu4e-sent-folder . "/personal/[Gmail]/Sent Mail")
		  (mu4e-refile-folder . "/personal/[Gmail]/All Mail")
		  (mu4e-trash-folder . "/personal/[Gmail]/Trash")
		  (mu4e-maildir-shortcuts . (
					      ("/personal/Inbox" . ?i)
					      ("/personal/[Gmail]/Sent Mail" . ?s)
					      ("/personal/[Gmail]/Trash" . ?t)
					      ("/personal/[Gmail]/Drafts" . ?d)
					      ("/personal/[Gmail]/All Mail" . ?a)
					      ))
		  ))
	 ))
  )
  #+end_src

* RSS Feeds
  RSS Feeds are the oldy but goldy way for news .
  In simple words , it is a XML file with a list of all the current news and links provided for more information.

  I use elfeed as my RSS Feed reader. You have to provide a list of feeds you want to follow .
  I also customized it's behaviour to include some unique ways of opening urls.
  #+begin_src emacs-lisp
(use-package elfeed
  :custom
  (elfeed-show-entry-switch #'elfeed-display-buffer)
  (elfeed-feeds
	'(
	  ( "https://www.techrepublic.com/rssfeeds/articles/" article tech )
	  ( "https://opensource.com/feed " opensource tech )
	  ( "http://feeds.bbci.co.uk/news/rss.xml?edition=int" news )
	  ( "https://www.cnet.com/rss/news/" news )
	  ( "https://www.space.com/feeds/all" news space )
	  ( "https://towardsdatascience.com/feed" programming )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCVls1GmFKf6WlTraIb_IaJg" youtube linux )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCylGUf9BvQooEFjgdNudoQg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCXuqSBlHAE6Xw-yeJA0Tunw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCld68syR8Wi-GY_n4CaoJGA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCsnGwSIHyoYN0kiINAGUKxg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC6uKrU_WqJ1R2HMTY3LIx5Q" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCL6JmiMXKoXS6bpP1D3bk8g" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCMiJRAwDNSNzuYeN2uWa0pA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBJycsmduvYEL83R_U4JriQ" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBNHHEoiSF8pcLgqLKVugOw" youtube )
	  ( "https://xkcd.com/rss.xml" blog )
	  ( "https://planet.emacsen.org/atom.xml" emacs )
	  ( "https://www.reddit.com/r/emacs/.rss" emacs reddit )
	  ( "https://www.reddit.com/r/linux/.rss" linux reddit )
	  ( "https://www.reddit.com/r/linuxmemes/.rss" linux reddit )
	  ( "https://www.reddit.com/r/vim/.rss" vim reddit )
	  ( "https://www.reddit.com/r/neovim/.rss" vim reddit )
	  ( "https://www.reddit.com/r/archlinux/.rss"  linux  reddit )
	  ( "https://www.reddit.com/r/awesomewm/.rss" linux reddit )
	  ( "https://www.reddit.com/r/google/.rss" news reddit )
	  ( "https://www.reddit.com/r/Python/.rss" programming reddit )
	  ( "https://www.reddit.com/r/suckless/.rss" linux reddit )
	  ( "https://www.reddit.com/r/techhumor/.rss" blog reddit )
	  ( "https://www.reddit.com/r/unixporn/.rss" linux reddit )
	  ( "https://www.reddit.com/r/listentothis/.rss" reddit )
	  ( "https://drewdevault.com/blog/index.xml" blog )
	  ( "https://unixsheikh.com/feed.rss" blog tech)
	  ( "https://mikestone.me/feed.xml" blog tech)
	  ( "https://www.phoronix.com/rss.php" news)
	  ( "https://fedoramagazine.org/feed/" linux news)
	  ( "https://robertheaton.com/feed" blog )
	  ( "https://reddit.com/r/vimkeyboard/.rss" linux  reddit)
	  ( "https://reddit.com/r/vimporn/.rss" linux reddit)
	  ( "https://reddit.com/r/commandline/.rss" programming reddit)
	  ( "https://distrowatch.com/news/dwd.xml" linux )
	  ( "https://lxer.com/module/newswire/headlines.rss" news )
	  ( "https://betanews.com/feed" news )
	  ( "https://www.computerworld.com/category/linux/index.rss" news )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC88tlMjiS7kf8uhPWyBTn_A"  youtube)
	  ( "http://www.polygon.com/rss/index.xml" news blog )
	  ( "http://www.dumbingofage.com/feed/" blog )
	  ( "http://www.smbc-comics.com/rss.php" blog )
	  ( "http://feeds.feedburner.com/codinghorror" tech news)
	  ( "https://news.ycombinator.com/rss" news)
	  ( "http://waitbutwhy.com/feed" blog )
	  ( "http://www.gunnerkrigg.com/rss.xml" blog)
	  ( "https://reddit.com/r/technology/.rss"  tech  reddit)
	  ( "https://reddit.com/r/games/.rss"  gaming)
	  ( "http://rss.slashdot.org/Slashdot/slashdot"  tech)
	  ( "https://www.cyberciti.biz/atom/atom.xml" tech news)
	  ( "https://www.gamingonlinux.com/article_rss.php" gaming linux)
	  ( "https://feeds.feedburner.com/Ostechnix" linux tech)
	  ( "https://omgubuntu.co.uk/feed" tech linux)
	  ( "https://www.tecmint.com/feed/" tech news)
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCsBjURrPoezykLs9EqgamOA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC88tlMjiS7kf8uhPWyBTn_A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCCIHOP7e271SIumQgyl6XBQ" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCP2bshADPrVMoNrdJvZEQzw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCP2bshADPrVMoNrdJvZEQzw" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UC-x4oXG1CJPrhMiARkW9b3A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCRE3NFNtdjR96-H4QG4U1Fg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCxwcmRAmBRzZMNS37dCgmHA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCXPHFM88IlFn68OmLwtPmZA" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCBa659QWEk1AI5Tg--mrJ2A" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCAiiOTio8Yu69c3XnR7nQBQ" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCbfYPyITQ-7l4upoX8nvctg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCbfYPyITQ-7l4upoX8nvctg" youtube )
	  ( "https://youtube.com/feeds/videos.xml?channel_id=UCEXtPiqFrcdzFRKqwazI1NA" youtube )
	  ( "https://pspiagicw.github.io/rss.xml" personal )
          ("https://colekillian.com/index.xml" tech blog)
          ( "https://nullprogram.com/feed/" tech blog)
          ( "https://sachachua.com/blog/category/emacs-news/feed/" emacs news)

	)
  )
)
  #+end_src
  
* IRC
  IRC is a old protocol for chatting.
  You have to join a IRC server , thus required registering.
  Good thing is that you can register from the IRC client.
  So no web required!

  #+begin_src emacs-lisp
(use-package erc
  :ensure nil
  :custom
  (erc-server "irc.libera.chat")
  (erc-nick "pspiagicw")
  (erc-user-full-name "pspiagicw")
  (erc-track-shorten-start 8)
  (erc-kill-buffer-on-part t)
  (erc-fill-functional 'erc-fill-static)
  (erc-fill-static-center 22)
  )
  #+end_src
  
* Dired
  Dired is the default ~directory-editor~ inbuilt into Emacs.
  Features include
  * Encryption
  * ZIP , Tar , GZ support
  * Bulk Operations on Files
  * Change modes , owners of Files

  Dired Dwim Target Allows Drag-n-Drop type copy and rename functionality
  #+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :config
  (setq dired-dwim-target t)
  )

  #+end_src
  Dired by default is purely text representation
  But we can extend by using ~dired-icons~ which add icons in Dired.
  #+begin_src emacs-lisp
;; (use-package all-the-icons-dired
;; )
  #+end_src
  
  Dired also has support for toggling visiblity of files according to a regex.
  ~dired-hide-dotfiles~ allows us to toggle hidden files in a single keypress
  
  #+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :hook
  (dired-mode . dired-hide-dotfiles-mode)
)
  #+end_src

* Browsing the Internet
  Browsing the internet using Emacs is possible using EWW.
  EWW allows basic text browsing , bookmarking .
  It does not support javascript ofcourse!
  #+begin_src emacs-lisp
(use-package eww
  :ensure nil
  :custom
  (shr-use-fonts nil)
  (shr-use-colors t)
  (shr-indentation 2)
  (shr-width 150)
  )
  #+end_src

  #+begin_src emacs-lisp
(add-hook 'eww-after-render-hook #'prot-eww--rename-buffer)
(advice-add 'eww-back-url :after #'prot-eww--rename-buffer)
(advice-add 'eww-forward-url :after #'prot-eww--rename-buffer)
  #+end_src


  #+begin_src emacs-lisp
(setq browse-url-browser-function 'custom-browse-url)
(setq browse-url-secondary-browser-funcion 'browse-url-generic)
(setq browse-url-generic-program "qutebrowser")
  #+end_src

  If you want a proper GUI web browser , look at Emacs Application Framework(EAF).
  
* Buffer Management
  The following section allows us to customize the buffer system of Emacs.
  This includes ~ibuffer~ and buffer-naming in general
  #+begin_src emacs-lisp
(use-package ibuffer
  :ensure nil
  :config
    (setq ibuffer-saved-filter-groups
	(quote (("default"
		("dired" (mode . dired-mode))
		("erc" (mode . erc-mode))
		("internet" (or
			     (mode . eww-mode)
			     (mode . elfeed-mode)
			     (mode . eaf-mode)))
		("emacs" (or
			    (name . "^\\*.*\\*$")))
		("media" (or
			  (name . "\\.png")
			  (name . "\\.jpeg")
			  (name . "\\.svg"))) ; group by file extension
		("gnus" (or
			    (mode . message-mode)
			    (mode . bbdb-mode)
			    (mode . mail-mode)
			    (mode . gnus-group-mode)
			    (mode . gnus-summary-mode)
			    (mode . gnus-article-mode)
			    (name . "^\\.bbdb$")
			    (name . "^\\.newsrc-dribble")))))))
    (add-hook 'ibuffer-mode-hook
	      (lambda () (ibuffer-switch-to-saved-filter-groups "default")))
)
  #+end_src
  
* Opening Files
  Opening files using Dired , opens in the corresponding mode.
  Images open in Image View Mode
  Documents including Office documents open in Doc View Mode.
  But behaviour may or may not be desired.

  Open With package provides a ~openwith-mode~ . This mode has internal list of which filetypes to be opened in which external programs.
  By default it is disabled , as lightwieight files can be opened inside Emacs without any problem.
  But for opening large files , I have assigned a keybinding for toggling ~openwith-mode~.
  
  #+begin_src emacs-lisp
(use-package openwith
  :custom
  (openwith-associations
   (list
    (list (openwith-make-extension-regexp
	   '("mpg" "mpeg" "mp3" "mp4"
	     "avi" "wmv" "wav" "mov" "flv"
	     "ogm" "ogg" "mkv" "opus" "m4a"))
	  "mpv --force-window"
	  '(file))
    (list (openwith-make-extension-regexp
	   '("xbm" "pbm" "pgm" "ppm" "pnm"
	     "png" "gif" "bmp" "tif" "jpeg" "jpg"))
	  "feh"
	  '(file))
    (list (openwith-make-extension-regexp
	   '("doc" "xls" "ppt" "odt" "ods" "odg" "odp" "docx" "pptx" "xlsx"))
	  "libreoffice"
	  '(file))
    (list (openwith-make-extension-regexp
	   '("pdf" "djvu"))
	  "zathura"
	  '(file))
    '("\\.lyx" "lyx" (file))
    '("\\.chm" "kchmviewer" (file))
    (list (openwith-make-extension-regexp
	   '("png" "jpeg" "jpg"))
	  "feh"
	  '(file))
    ))
  :config
  (openwith-mode -1)
  )
  #+end_src
  

  
* Custom Functions
  These functions do my custom actions on some keybindings. These are written by me and changed if needed.
  These may or may not be useful for your setup. Or make your own!
  
** EWW Rename Buffer
   This piece of function changes the name of eww buffer on changing the site by going , forward or backward into the history.
   Originally taken from Protisilousâ€™s Emacs Config.
   
   #+begin_src emacs-lisp
(defun prot-eww--rename-buffer ()
  "Rename EWW buffer using page title or URL.
To be used by `eww-after-render-hook'."
  (let ((name (if (eq "" (plist-get eww-data :title))
		  (plist-get eww-data :url)
		(plist-get eww-data :title))))
    (rename-buffer (format "*%s # eww*" name) t)))
   #+end_src
   
** Elfeed Display Buffer
   This function is a handler for when elfeed wants to display a elfeed entry.
   This function controls how that is shown.
   Right Now it is displayed in any configuration covering 70% of the frame.
   Emacs decides how does it want to dispaly the buffer , but always makes sure , it is not more than 70% of the frame.
   
   
   #+begin_src emacs-lisp
(defun elfeed-display-buffer (buf &optional act)
  (display-buffer buf)
  (set-window-text-height (get-buffer-window) (round (* 0.7 (frame-height)))))
   #+end_src
   
** Kill Dired Buffers
   This function kills all dired buffer in the background!
   It is useful if you think there are a lot of dired buffers and want to kill them
   #+begin_src emacs-lisp
(defun kill-dired-buffers ()
  (interactive)
  (mapc (lambda (buffer) 
	  (when (eq 'dired-mode (buffer-local-value 'major-mode buffer)) 
	    (kill-buffer buffer))) 
	(buffer-list)))
   #+end_src
   
** Custom Switch to Next Theme
   This custom function switches to the next theme.
   Requires initializing a variable known as the theme-index
   #+begin_src emacs-lisp
(setq theme-index 0)
(defun custom-switch-to-next-theme ()
  "Switch to next theme"
  (interactive)
  (let (
	(theme-name (nth theme-index (custom-available-themes)))
	)
    (message "Current Theme: %s" theme-name)
    (setq theme-index (+ theme-index 1))
    (if (> theme-index (length (custom-available-themes)))
	(setq theme-index 0))
    (load-theme theme-name t)

    ))
   #+end_src
   
** Custom Switch to Dashboard
   This function simply finds a buffer named ~*dashbord*~ and switches to it.
   #+begin_src emacs-lisp
(defun custom-switch-to-dashboard ()
  "Switch to dashboard"
  (interactive)
  (switch-to-buffer (get-buffer "*dashboard*"))
  )
   #+end_src
   
** Custom Terminal
   This function controls what happens when I want to open a terminal
   If I am inside a project , I mostly want to open a terminal in the project root.
   Or else I want a terminal then and there, no questions asked!
   #+begin_src emacs-lisp
(defun custom-terminal ()
  "Open a terminal differently depending on whether on project or not"
  (interactive)
  (if (projectile-project-p)
      (project-shell)
    (term "/bin/bash")))
(setq original-directory "~/.config")
(setq counter 0)
(defun custom-new-terminal ()
  "Open a new terminal if directory changed"
  (interactive)
  (if (string= original-directory 'default-directory)
      (shell)
    (progn
      (setq counter (+ counter 1))
      (setq title (concat "term-" (number-to-string counter)))
      (setq buf-title (concat "*" title "*"))
      (message buf-title)
      (set-buffer (make-term title "/bin/bash"))
      (term-mode)
      (term-char-mode)
      (switch-to-buffer buf-title)
      )
    )
  )
   #+end_src
   
** Custom Grep
   In the same way ~custom-terminal~ works. Custom Grep defines where do I start grepping ?
   In a project projectil-grep takes over and greps over the whole project.
   Or else I simply grep over the current file or directory
   #+begin_src emacs-lisp
(defun custom-grep ()
  "Determines if in project or not and calls required grep function"
  (interactive)
  (if (projectile-project-p)
      (project-find-regexp)
    (counsel-grep)))
   #+end_src
   
** Custom Browse URL
   This function decides where to open a link.
   #+begin_src emacs-lisp
(defun custom-open-eww ()
  (interactive)
  (eww-browse-url url-to-open)
  )
(defun custom-browse-url-generic ()
  (interactive)
  (browse-url-generic url-to-open)
  )
(defun custom-reddigg-url ()
  (interactive)
  (reddigg-view-comments url-to-open)
  )
(defun custom-browse-url (url &optional a)
    "Browse URL"
    (setq url-to-open url)
    (command-execute 'hydra-url/body)
)
(defun custom-eaf-open-browser ()
  "Browser url in EAF Browser"
  (interactive)
  (eaf-open-browser url-to-open)
)
(defun custom-mpv-hander ()
  (interactive)
  (async-shell-command (format "mpv %s" url-to-open))
  )
(defun custom-youtube-query ()
  (interactive)
  (browse-url (format "https://invidious.kavin.rocks/search?q=%s" (read-string "Youtube Search: ")))
  )


   #+end_src
   
** Custom Vsplit
   This vpslit function works as vim splits.
   It splits and takes me to the new split.
   #+begin_src emacs-lisp
(defun custom-vsplit ()
  "Custom vpslit with focus going to split"
  (interactive)
  (evil-window-vsplit)
  (evil-window-right 1))
   #+end_src
   
** Custom Split
   Same as the vsplit , only horizontally
   #+begin_src emacs-lisp
(defun custom-split ()
  "Custom vpslit with focus going to split"
  (interactive)
  (evil-window-split)
  (evil-window-down 1)
)

   #+end_src
   
** Custom Find file
   If in a project runs ~counsel-projectile-find-file~ or else runs standrd ~counsel-find-file~.
   #+begin_src emacs-lisp
(defun custom-find-file ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (project-find-file)
    (command-execute 'find-file)
    )
)
   #+end_src
   
** Custom Occur
   Occur is a interesting inbuilt package , as it shows us a good summary of what it found.
   Like all my previous function , this runs file based occur if not in a project.
   If yes , it simply runs inside the project.
   #+begin_src emacs-lisp
(defun custom-occur ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (projectile-multi-occur)
    (command-execute 'occur)))
   #+end_src
   
** Custom Switch Buffer
   This function also switches between the project buffers when inside a project.
   And switches between global buffers when outside.
   #+begin_src emacs-lisp
(defun custom-switch-buffer ()
  "Determines if in project or not and calls required find-file function"
  (interactive)
  (if (projectile-project-p)
      (project-switch-project)
    (command-execute 'switch-to-buffer))
)
   #+end_src
   
** Custom Dired
   This too works like expected.
   #+begin_src emacs-lisp
(defun custom-dired ()
  "Calls dired depending if in project or not"
  (interactive)
  (if (projectile-project-p)
      (project-find-dir)
    (dired (read-directory-name "Dired (directory): "))))

   #+end_src
** Custom Elfeed Back
   This function is built as a alternative the standard elfeed quit.
   This function switches to the ~*elfeed*~ buffer on quiting.
   But becuase of the elfeed customization , this function is rendered useless.
   Kept if needed in the future and as a future reference.
   #+begin_src emacs-lisp
(defun custom-elfeed-back()
  (interactive)
  (elfeed-kill-buffer)
  (switch-to-buffer "*elfeed-search*")
  )
   #+end_src
** Custom MPC Functions
   The functions below are used to control the MPC interface inside Emacs.
   MPC is a inbuilt mode to control the mpd server in Emacs
   #+begin_src emacs-lisp
(defun move-mpc-down ()
  (interactive)
  (evil-next-visual-line)
  (mpc-select)
 )
(defun move-mpc-up ()
  (interactive)
  (evil-previous-visual-line)
  (mpc-select)
 )
(defun increase-mpc-volume ()
  (interactive)
  (async-shell-command "mpc volume +5")
)

(defun decrease-mpc-volume ()
  (interactive)
  (async-shell-command "mpc volume -5")
 )
 
   #+end_src
** Custom CRUX Open With
   This provides the ~t~ argument to the ~crux-open-with~ function , which prompts for the program to open the file in.
   #+begin_src emacs-lisp
(defun custom-crux-open-with ()
  "CRUX Open with for files"
  (interactive)
  (crux-open-with t)
  )
   #+end_src
** Custom Counsel Functions
   These functions provide custom counel commands.
   These range from opening commands to changing wallpaper
   Edit: Although this was the case , I switched to completing-read for better integration with native-emacs.
*** Complete ConfigEdit
    #+begin_src emacs-lisp
(setq config-dict '(
		    (alacritty . "~/.config/alacritty/alacritty.yml")
		    (emacs . "~/.config/emacs/emacs.org")
		    (xmonad . "~/.xmonad/xmonad.org")
		    (bash . "~/.bashrc")
		    (dunst . "~/.config/dunst/dunstrc")
		    (xmobar . "~/.config/xmobar/xmobarrc")
		    ))
(defun custom-confedit ()
  "Edit a config file"
  (interactive)
  (find-file (alist-get (intern (completing-read "Edit Config: " (mapcar 'car (car (list config-dict))))) config-dict)))


#+end_src
*** Complete Select Theme
#+begin_src emacs-lisp
(defun custom-list-of-themes ()
  "Get a list of themes"
  (let ((suffix "-theme\\.el\\'")
        themes)
    (dolist (dir (custom-theme--load-path))
      (dolist (file (and (file-directory-p dir)
                         (directory-files dir nil suffix)))
        (let ((theme (intern (substring file 0 (string-match-p suffix file)))))
          (and (custom-theme-name-valid-p theme)
               (not (memq theme themes))
               (push theme themes)))))
    (nreverse themes)))
(defun custom-select-theme ()
  "Select a theme"
  (interactive)
  (setq theme-selection(intern (completing-read "Choose a theme: " (custom-list-of-themes) )))
  (mapc #'disable-theme (custom-list-of-themes))
  (load-theme theme-selection t)
  )
#+end_src 
*** Complete Terminal
#+begin_src emacs-lisp
(defun custom-terminal-app ()
  "Select Terminal Apps"
  (interactive)
  (setq terminal-list (list "cava" "nvtop" "top" "ncmpcpp" "mmtc" "btm" "pulsemixer" "tremc"))
  (async-shell-command (format "alacritty -e %s" (completing-read "Select App:" terminal-list)))
)

#+end_src

*** Counsel Wallpaper
    #+begin_src emacs-lisp
(defun custom-select-wallpaper ()
  "Change wallpaper"
  (interactive)
  (setq wallpaper-directory "~/.config/wallpaper/wallpapers")
  (async-shell-command (format "feh --no-fehbg --bg-fill %s/%s" wallpaper-directory (completing-read "Choose file: " (directory-files wallpaper-directory)))))
    #+end_src
*** Complete RecentF
    #+begin_src emacs-lisp
(defun custom-recentf-candidates ()
  "Return recent files"
  (if (and counsel-recentf-include-xdg-list
           (>= emacs-major-version 26))
      (delete-dups
       (sort (nconc (mapcar #'substring-no-properties recentf-list)
                    (counsel--recentf-get-xdg-recent-files))
             (lambda (file1 file2)
               (cond ((file-remote-p file1)
                      nil)
                     ((file-remote-p file2))
                     (t
                      ;; Added in Emacs 26.1.
                      (declare-function file-attribute-access-time "files"
                                        (attributes))
                      (time-less-p (file-attribute-access-time
                                    (file-attributes file2))
                                   (file-attribute-access-time
                                    (file-attributes file1))))))))
    (mapcar #'substring-no-properties recentf-list)))
(defun custom-select-recentf ()
  "Find a file on `recentf-list'."
  (interactive)
  (find-file (completing-read "Recentf: " (custom-recentf-candidates)))
  )
    #+end_src
* Keybindings
  Keybindings are the most wonderful aspect of the Emacs text editor.
  It originally has very complex keybindings , that only make sense to the experienced Emacs user.

  I use my own keybindings that use SPC key as the leader key. That means I control editor throught keybindings starting with SPC.
  Example

  For opening a file irrespective of my location , I press "SPC ." , which calls a function that does it for me.

  These are a little complex to implement and there are libraries that make it easy to bind keys.

  Some of them are ~bind-keys~ and ~general~ . Both of them are very customizable and can declare complex keybinding schemes.

  I use ~general~ due to the fact that ~Doom Emacs~ used them , I was a previous user of Doom Emacs.

  
** General Installation
   General can be installed using ~use-package~ like any other package. For evil-mode users it includes the ~general-evil-setup~ variable.
   The syntax of general is quite easy to understand but albeit complex to implement it yourself.
   #+begin_src emacs-lisp
(use-package general)
   #+end_src
** Hydra
   Hydra is a unique package that gives us power to declare transient modes.
   This is very similar to the Magit status buffer, where every action is executed using one or more keystrokes.

   Installation is using ~use-package~
   #+begin_src emacs-lisp
(use-package hydra)
   #+end_src

   
*** Hydra Window
    This hydra defines transient state for manipulating windows.
    #+begin_src emacs-lisp
(defhydra hydra-window (:color red
                        :hint nil)
  "
 Split: _v_ert _x_:horz
Delete: _o_nly  _da_ce  _dw_indow  _db_uffer  _df_rame
  Move: _s_wap
Frames: _f_rame new  _df_ delete
  Misc: _m_ark _a_ce  _u_ndo  _r_edo"
  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("H" hydra-move-splitter-left)
  ("J" hydra-move-splitter-down)
  ("K" hydra-move-splitter-up)
  ("L" hydra-move-splitter-right)
  ("|" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right)))
  ("_" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)))
  ("v" split-window-right)
  ("x" split-window-below)
  ;("t" transpose-frame "'")
  ;; winner-mode must be enabled
  ("u" winner-undo)
  ("r" winner-redo) ;;Fixme, not working?
  ("o" delete-other-windows :exit t)
  ("a" ace-window :exit t)
  ("f" new-frame :exit t)
  ("s" ace-swap-window)
  ("da" ace-delete-window)
  ("dw" delete-window)
  ("db" kill-this-buffer)
  ("df" delete-frame :exit t)
  ("q" nil)
  ;("i" ace-maximize-window "ace-one" :color blue)
  ;("b" ido-switch-buffer "buf")
  ("m" headlong-bookmark-jump)
)
    #+end_src
    
*** Browse URL Transient State 
    This defines a transient state which decides what to do with a given url
    #+begin_src emacs-lisp
(defhydra hydra-url (:exit t)
  "Browse URL"
  ("e" custom-open-eww "eww")
  ("b" custom-browse-url-generic "external browser")
  ("m" custom-mpv-handler "Open with MPV")
  ("r" custom-reddigg-url "Open in Reddigg")
)

    #+end_src

*** LSP Transient State
    This defines a transient state for managing buffers
    #+begin_src emacs-lisp
(defhydra hydra-lsp (:exit t :hint nil)
  "
 Buffer^^               Server^^                   Symbol
-------------------------------------------------------------------------------------
 [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
 [_m_] imenu            [_S_]   shutdown           [_D_] definition   [_t_] type            [_r_] rename
 [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature"
  ("d" lsp-find-declaration)
  ("D" lsp-ui-peek-find-definitions)
  ("R" lsp-ui-peek-find-references)
  ("i" lsp-ui-peek-find-implementation)
  ("t" lsp-find-type-definition)
  ("s" lsp-signature-help)
  ("o" lsp-describe-thing-at-point)
  ("r" lsp-rename)

  ("f" lsp-format-buffer)
  ("m" lsp-ui-imenu)
  ("x" lsp-execute-code-action)

  ("M-s" lsp-describe-session)
  ("M-r" lsp-restart-workspace)
  ("S" lsp-shutdown-workspace)
 )
    #+end_src
    
*** Toggling Transient State
    #+begin_src emacs-lisp
(defhydra hydra-toggle ()
  "Toggle Settings"
  ("a" custom-open-eww "eww")
  ("b" custom-browse-url-generic "external browser")
  ("r" custom-reddigg-url "reddigg")
)
    #+end_src
    
** Main Keybindings
   These are the heart of my configuration . Customized by only me , these control the basic movement and usage of the editor.

   These are grouped by their actions i.e keybindings related to windows are invoked by prefix "SPC w".
   #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
  ";" '(execute-extended-command :which-key "Execute a Command")
  ">" '(evil-next-buffer :which-key "Move to Next Buffer")
  "<" '(evil-prev-buffer :which-key "Move to Prev Buffer")
  "/" '(consult-line :which-key "Grep in Current Buffer")
  "." '(find-file :which-key "Find File")
  "!" '(shell-command :which-key "Execute Shell Command")
  "&" '(async-shell-command :which-key "Execute Shell Command Async")
  "RET" '(bookmark-jump :which-key "Browse Bookmarks")
)
   #+end_src

   
*** Buffer
    #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "b" '(:ignore t :which-key "Buffer")
 "bn" '(evil-next-buffer :which-key "Switch to next buffer")
 "bp" '(evil-prev-buffer :which-key "Switch to prev buffer")
 "bb" '(switch-to-buffer :which-key "Switch to Buffer")
 "br" '(rename-buffer :which-key "Rename buffer")
 "bd" '(evil-delete-buffer :which-key "Delete Buffer")
 "bi" '(ibuffer :which-key "Open Ibuffer")
 "bR" '(read-only-mode :which-key "Toggle Read Only Mode")
 "bs" '(crux-create-scratch-buffer :which-key "Make a new scratch buffer")
 "bw" '(switch-to-buffer-other-window :which-key "Switch to buffer in other window")
 )
    #+end_src

*** Files
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "f" '(:ignore t :which-key "Files")
 "ff" '(find-file :which-key "Find Files Interactively")
 "fs" '(save-buffer :which-key "Save Current Buffer")
 "fS" '(save-some-buffers :which-key "Save Current Buffer")
 "fr" '(consult-recent-file :which-key "Find Recent Files")
 "fR" '(rename-file :which-key "Rename File")
 "fC" '(copy-file :which-key "Copy File")
 "fl" '(locate :which-key "Locate File")
 "fo" '(custom-crux-open-with :which-key "Locate File")
 "fh" '(find-file :which-key "Locate File")
 "fw" '(find-file-other-window :which-key "Find File Other Window")
)
    #+end_src

*** Toggles
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "t" '(:ignore t :which-key "Toggle")
 "tt" '(shell :which-key "Toggle Terminal")
 "tn" '(display-line-numbers-mode :which-key "Toggle Line Numbers")
 "tk" '(which-key-mode :which-key "Toggle Which Key")
 "ta" '(company-mode :which-key "Toggle Autocompletion")
 "tA" '(global-company-mode :which-key "Toggle Autocompletion")
 "tM" '(menu-bar-mode :which-key "Toggle Menu Bar")
 "tf" '(auto-fill-mode :which-key "Toggle Whitespace mode")
 "ti" '(electric-indent-local-mode :which-key "Toggle Auto Indenting")
 "tl" '(hl-line-mode :which-key "Toggle Line Hightlight")
 "tf" '(flymake-mode :which-key "Toggle Flymake")
 "tF" '(text-scale-adjust :which-key "Toggle font sizes")
 "tp" '(electric-pair-local-mode :which-key "Toggle Pairing")
 "tP" '(electric-pair-mode :which-key "Toggle Pairing")
 "tw" '(whitespace-mode :which-key "Toggle Whitespace Mode")
 "ts" '(consult-theme :which-key "Toggle Whitespace Mode")
 "tm" '(custom-music-toggle :which-key "Toggle Music")
)
    #+end_src

*** Narrow
    #+begin_src emacs-lisp

(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "n" '(:ignore t :which-key "Narrow")
 "nr" '(narrow-to-region :which-key "Narrow Region")
 "nf" '(narrow-to-defun :which-key "Narrow to Function")
 "np" '(narrow-to-page :which-key "Narrow to Page")
)
    #+end_src

*** Help
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "h" '(:ignore t :which-key "Help")
 "hf" '(describe-function :which-key "Describe Function")
 "hv" '(describe-variable :which-key "Describe Variable")
 "hc" '(describe-key :which-key "Describe Key")
 "hp" '(describe-package :which-key "Describe Package")
 "hi" '(info :which-key "Info Manuals")
 "hm" '(describe-mode :which-key "Describe Mode")
)
    #+end_src
    
*** Projects
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "p" '(:ignore t :which-key "Projects")
 "pp" '(project-switch-project :which-key "Switch Project")
 "pc" '(project-compile :which-key "Compile Project")
 ;; "pt" '(projectile-test-project :which-key "Test Project")
 "pf" '(project-find-file :which-key "Find File in Project")
 "ps" '(project-search :which-key "Grep in your Project")
 "pr" '(projectile-run-project :which-key "Run Project")
 "pb" '(project-switch-to-buffer :which-key "Switch to Buffer in Project")
 "pk" '(project-kill-buffers :which-key "Kill all Project buffers")
 "p&" '(project-async-shell-command :which-key "Run Command Async in Project")
 "p!" '(project-shell-command :which-key "Run Command in Project")
 "pd" '(project-dired :which-key "Open Dired on Project Root")
 ;; "pg" '(projectile-find-tags :which-key "Find Tags in Project")
 ;; "p%" '(projectile-replace-regexp :which-key "Replace Name in Project")
 "p'" '(project-shell :which-key "Run shell in Root of Project")
)
#+end_src
    
*** Dired
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "d" '(:ignore t :which-key "Dired")
 "dk" '(kill-dired-buffers :which-key "Kill Dired Buffers")
 "dd" '(dired :which-key "Open Dired")
)
    #+end_src
    
*** Git
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "g" '(:ignore t :which-key "Git")
 "gg" '(magit-status :which-key "Git Status")
 "gc" '(magit-clone :which-key "Git Clone")
)
    #+end_src
    
*** Window
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "w" '(:ignore t :which-key "Window")
 "wv" '(custom-vsplit :which-key "Split Vertically")
 "ws" '(custom-split :which-key "Split Horizonatally")
 "wc" '(evil-window-delete :which-key "Delete Window")
 "w=" '(balance-windows :which-key "Balance Windows")
 "wh" '(evil-window-left :which-key "Move to Left Window")
 "wl" '(evil-window-right :which-key "Move to Right Window")
 "wj" '(evil-window-down :which-key "Move to Below Window")
 "wk" '(evil-window-up :which-key "Move to Top Window")
 "wo" '(delete-other-windows :which-key "Delete other Windows")
 "wu" '(winner-undo :which-key "Undo Window Configuration")
 "wr" '(winner-redo :which-key "Redo Window Configuration")
 "w." '(hydra-window/body :which-key "Window Transient State")
)
    #+end_src
    
*** LSP
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "ll" '(lsp :which-key "Start/Connect with LSP Server")
 "l." '(hydra-lsp/body :which-key "LSP Transient State")
 "li" '(lsp-organize-imports :which-key "LSP Organize imports")
 "lf" '(lsp-format-buffer :which-key "Lsp Format Buffer")
 "lr" '(lsp-rename :which-key "Lsp Rename")
 )
    #+end_src
    
*** Search
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "s" '(:ignore t :which-key "Search")
 "sg" '(grep-find :which-key "Search Using Grep Recursively")
 "ss" '(grep :which-key "Search Using Grep")
 "so" '(occur :which-key "Search Using Occur")
 "sr" '(consult-ripgrep :which-key "Search Using Occur")
)
    #+end_src
    
*** Apps
    
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "o" '(:ignore t :which-key "Open Applications")
 "oo" '(openwith-mode :which-key "Toggle OpenWith Mode")
 "or" '(re-builder :which-key "Open Reddit")
 "oa" '(org-agenda :which-key "Org Agenda")
 "om" '(mpc :which-key "Open Simple MPC")
 "ob" '(eww :which-key "Open Browser")
 "oB" '(eaf-open-browser :which-key "Open Browser")
 "oM" '(mu4e :which-key "Open Mu4e")
 "og" '(custom-googler :which-key "Open EWW")
 "oc" '(org-capture :which-key "Open Org-Capture")
 "ot" '(term :which-key "Open Terminal")
 "oi" '(erc-tls :which-key "Open IRC")
)
    #+end_src
     
*** Jump
    We need to include some packages that are used for
    Jumping around

    Link Hint for jumping between links.
    
  #+begin_src emacs-lisp
(use-package link-hint)
  #+end_src
    Ace Window for jumping between window.
    
  #+begin_src emacs-lisp
(use-package ace-window)
  #+end_src
    Actual Keybindings
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'override
 :states '(normal visual)
 :prefix "SPC"
 "j" '(:ignore t :which-key "Jump")
 "ji" '(imenu :which-key "Jump to tag using Imenu")
 "jl" '(link-hint-open-link :which-key "Jump to link")
 "jw" '(ace-window :which-key "Jump to Window")
 "jn" '(next-error :which-key "Jump to next error")
 "jp" '(previous-error :which-key "Jump to next error")
 "jc" '(link-hint-copy-link :which-key "Copy given link")
 )
    #+end_src
    
*** Quit
    #+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :keymaps 'override
 :prefix "SPC"
 "qq" '(delete-frame :which-key "Delete Frame")
 )
    #+end_src
** Modal Keybindings
   These are keybindings that only work while in the particular mode.
   #+begin_src emacs-lisp
(general-define-key
 :keymaps 'override
 :states '(normal visual)
 :prefix "SPC"
 "m" '(:ignore t :which-key "Major Mode")
 )

   #+end_src
   
*** Python Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'python-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "mp" '(run-python :which-key "Open Python REPL")
 "mr" '(python-shell-send-region :which-key "Send region to REPL")
 "mb" '(python-shell-send-buffer :which-key "Send buffer to REPL")
 "mf" '(python-shell-send-defun :which-key "Send function to REPL")
 "ms" '(python-shell-send-statement :which-key "Send statement to REPL")
 "mi" '(:ignore t :which-key "Insert things")
 "mic" '(python-skeleton-class :which-key "Insert class skeleton")
 "mif" '(python-skeleton-for :which-key "Insert for skeleton")
 "mii" '(python-skeleton-import :which-key "Insert for skeleton")
 "mid" '(python-skeleton-def :which-key "Insert def skeleton")
 "mit" '(python-skeleton-try :which-key "Insert try skeleton")
 "miw" '(python-skeleton-while :which-key "Insert while skeleton")
 "mj" '(imenu :which-key "Jump to definition")
 )
(general-define-key
 :states '(normal visual)
 :keymaps 'python-mode-map
 "M-j" '(python-nav-forward-defun :which-key "Move to next function")
 "M-k" '(python-nav-backward-defun :which-key "Move to previous function")
 )

    #+end_src
    
*** Org Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'org-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "mt" '(:ignore t :which-key "org-toggle")
 "me" '(org-export-dispatch :which-key "Org Export")
 "mth" '(org-toggle-heading :which-key "Org Toggle Heading")
 "mti" '(org-toggle-item :which-key "Org Toggle Item")
 "mtt" '(org-todo :which-key "Org toggle todo")
 "mtc" '(org-toggle-checkbox :which-key "Org toggle checkbox")
 "ms" '(org-schedule :which-key "Org Schedul")
 "mc" '(org-ctrl-c-ctrl-c :which-key "Org Ctrl C")
 "ma" '(org-agenda-file-to-front :which-key "Org Agenda Add")
 "mi" '(org-insert-structure-template :which-key "Org Insert Structure")
 "mT" '(org-babel-tangle :which-key "Org Babel Tangle")
 "ml" '(org-insert-link :which-key "Org Insert Link")
 "ml" '(org-insert-link :which-key "Org Insert Link")
 "m'" '(org-edit-special :which-key "Org Edit Special")
 )
    #+end_src

*** Dired Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'dired-mode-map
 :states 'normal
 "h" 'dired-up-directory
 "l" 'dired-find-file
 "." 'dired-hide-dotfiles-mode
 "V" 'dired-mark
 "G" 'end-of-buffer
 "gg" 'beginning-of-buffer
)
    #+end_src
    
*** Elfeed Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'elfeed-show-mode-map
 :states 'normal
 "h" 'custom-elfeed-back
 "f" 'link-hint-open-link
 )
(general-define-key
 :keymaps 'elfeed-search-mode-map
 :states 'normal
 "l" 'elfeed-search-show-entry
 "L" 'scroll-other-window
 )
    #+end_src
    
*** Archive Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'archive-mode-map
 :states 'normal
 "h" 'quit-window
 "l" 'archive-extract
 )
    #+end_src
    
*** Emacs Lisp Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'emacs-lisp-mode-map
 :states '(normal visual)
 :prefix "SPC"
 "me" '(eval-last-sexp :which-key "evaluate last sexp")
 "m:" '(eval-expression :which-key "evaluate lisp func")
 "md" '(eval-defun :which-key "evaluate defun")
 "mb" '(eval-buffer :which-key "evaluate buffer")
 "mr" '(eval-region :which-key "evaluate region")
 "mj" '(imenu :which-key "Imenu Mode")
 )
    #+end_src

*** MPC Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'mpc-mode-map
 :states 'normal
 "j" 'move-mpc-down
 "k" 'move-mpc-up
 "t" 'mpc-toggle-play
 "r" 'mpc-repeat
 "S" 'mpc-toggle-shuffle
 "c" 'mpc-toggle-consume
 "a" 'mpc-playlist-add
 "p" 'mpc-playlist
 ">" 'mpc-next
 "<" 'mpc-prev
 "R" 'mpc-playlist-delete
 "x" 'mpc-play-at-point
 "RET" 'mpc-select
 "+" 'increase-mpc-volume
 "-" 'decrease-mpc-volume
 )
(general-define-key
 :keymaps 'mpc-status-mode-map
 :states 'normal
 "p" 'move-to-mpc-playlist
 )
    #+end_src

*** ERC Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'erc-mode-map
 :states 'normal
 :prefix "SPC"
 "mj" '(erc-join-channel :which-key "ERC Join Channel")
 "mp" '(erc-part-from-channel :which-key "ERC Part Channel")
 "mq" '(erc-quit-server :which-key "ERC Quit Server")
 "mb" '(erc-switch-to-buffer :which-key "ERC Switch Buffer")
 "mt" '(erc-set-topic :which-key "ERC Topic")
 "mn" '(erc-channel-names :which-key "ERC Names")
 )
    #+end_src

*** EWW Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'eww-mode-map
 :states 'normal
 "f" 'link-hint-open-link
)
    #+end_src
*** Info Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'Info-mode-map
 :states 'normal
 "f" 'link-hint-open-link
)

    #+end_src
*** Help Mode
    #+begin_src emacs-lisp
(general-define-key
 :keymaps 'help-mode-map
 :states 'normal
 "f" 'link-hint-open-link
)
    #+end_src
*** Org Agenda Mode
*** Shell Mode
    #+begin_src emacs-lisp
    #+end_src
* Misc Packages or Non-Structured Data

  #+begin_src emacs-lisp
;; Force OpenWith mode to close
(openwith-mode -1)
(scroll-bar-mode -1)
  #+end_src

  #+begin_src emacs-lisp
  #+end_src


  #+begin_src emacs-lisp
(use-package pdf-tools)
  #+end_src


  #+begin_src emacs-lisp
;; (use-package eaf
;;   :load-path "~/.config/emacs/emacs-application-framework"
;;   :custom
;;   (eaf-browser-enable-adblocker t)
;;   (eaf-browser-default-search-engine "google")
;;   (eaf-browser-blank-page-url "https://draculatheme.com")
  
;; )
;; (require 'eaf-browser)
 
  #+end_src


  #+begin_src emacs-lisp
  #+end_src

  #+begin_src emacs-lisp
(defun custom-googler ()
  "Google something"
  (interactive)
  (let ((query (read-string "Search for: ")))
    (eaf-open-browser (format "https://google.com/search?q=%s" query)))
	)
  #+end_src

  
  #+begin_src emacs-lisp
  #+end_src
  #+begin_src emacs-lisp
(defun custom-music-next ()
"Play the next music in MPD"
  (interactive)
(shell-command "mpc next")
)
(defun custom-music-prev ()
"Play the next music in MPD"
  (interactive)
(shell-command "mpc prev")
)
(defun custom-music-toggle ()
"Play the next music in MPD"
  (interactive)
(shell-command "mpc toggle")
)
(defun custom-music-toggle ()
"Play the next music in MPD"
  (interactive)
(shell-command "mpc toggle")
)
(general-define-key
 :prefix "SPC"
 :keymaps 'override
 :states 'normal
 "M" '(:ignore t :which-key "Music")
 "Mn" '(custom-music-next :which-key "Next Song")
 "Mp" '(custom-music-prev :which-key "Prev Song")
 )
  #+end_src



  

  #+begin_src emacs-lisp

  #+end_src
  #+begin_src emacs-lisp
(setq lsp-enabled-clients nil)
  #+end_src
  #+begin_src emacs-lisp
  #+end_src

  #+begin_src emacs-lisp
(use-package yasnippet)
(general-define-key
 :states 'insert
 "M-/" 'yas-expand
 )
  #+end_src
  #+begin_src go
fmt.Println("Hello World")

  #+end_src


  #+begin_src emacs-lisp
(use-package consult) 
  #+end_src
  
  #+begin_src emacs-lisp
(use-package reddigg)
  #+end_src
